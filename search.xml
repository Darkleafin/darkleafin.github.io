<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[EZOI][1225NOI模拟赛]farmer(树链剖分+线段树)]]></title>
    <url>%2F2018%2F12%2F26%2FEZOI-1225NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-farmer-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定一棵有 $n$ 个节点二叉树的第 $i$ 个节点的权值 $a_i$ 以及左右儿子编号（若不存在则为 $0$）。 给出 $m$ 次操作，每次操作均为以下 $3$ 种之一： $1\ u\ v$：将节点 $u$ 的权值修改为 $v$。 $2\ u$：将节点 $u$ 及其子树内所有点的左右儿子交换。 $3\ u$：询问从根开始走，若当前节点权值小于 $a_u$ 则向左儿子走，大于 $a_u$ 则向右儿子走，等于 $a_u$ 则停止，若能走到 $u$ 点则输出 YES，否则输出 NO。 $1\leq n,m\leq 10^5,\ \ 1\leq a_i,v\leq 10^9,\ \ 1\leq u\leq n$。 § 2 分析若不存在操作 $2$，容易发现一个节点 $u$ 可以被走到，当且仅当从根节点到它的路径上，向右儿子走的节点中的最大权值严格小于 $a_u$，且向左儿子走的节点中的最小权值严格大于 $a_u$。 考虑用树剖维护根到每个节点的路径上向右儿子走的节点的最大权值，以及向左儿子走的节点中的最小权值即可。 而子树翻转操作相当于将两个限制符号取反，所以再维护取反后的信息，子树翻转时交换并打标记即可。 总时间复杂度为 $O(m\log^2n)$。 § 3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAXN 100005#define inf 0x3f3f3f3fusing namespace std;typedef struct &#123;int mx, mn;&#125; Pair;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, m, a[100005], fa[100005], ch[100005][2], root;int siz[100005], seni[100005], dfn[100005], dout[100005], dfstime = 0, id[100005], top[100005];int mx[400005][2], mn[400005][2], rev[400005];#define lch (u &lt;&lt; 1)#define rch (u &lt;&lt; 1 | 1)inline void update(const int &amp;u)&#123; mx[u][0] = max(mx[lch][0], mx[rch][0]); mx[u][1] = max(mx[lch][1], mx[rch][1]); mn[u][0] = min(mn[lch][0], mn[rch][0]); mn[u][1] = min(mn[lch][1], mn[rch][1]);&#125;inline void pushdown(const int &amp;u)&#123; if(!rev[u]) return; swap(mx[lch][0], mx[lch][1]), swap(mx[rch][0], mx[rch][1]); swap(mn[lch][0], mn[lch][1]), swap(mn[rch][0], mn[rch][1]); rev[lch] ^= 1, rev[rch] ^= 1, rev[u] = 0;&#125;void build(const int &amp;u, const int &amp;l, const int &amp;r)&#123; if(l == r)&#123; mx[u][0] = mx[u][1] = -inf, mn[u][0] = mn[u][1] = inf; const int &amp;dir = seni[id[l]]; if(~dir) mx[u][dir] = mn[u][dir] = a[fa[id[l]]]; return; &#125; const int mid = l + r &gt;&gt; 1; build(lch, l, mid), build(rch, mid + 1, r), update(u);&#125;void modify(const int &amp;u, const int &amp;l, const int &amp;r, const int &amp;p, const int &amp;v)&#123; if(l == r)&#123; mx[u][0] = mx[u][1] = -inf, mn[u][0] = mn[u][1] = inf; const int &amp;dir = seni[id[l]]; if(~dir) mx[u][dir] = mn[u][dir] = v; if(rev[u]) swap(mx[u][0], mx[u][1]), swap(mn[u][0], mn[u][1]); return; &#125; const int mid = l + r &gt;&gt; 1; pushdown(u); if(p &lt;= mid) modify(lch, l, mid, p, v); else modify(rch, mid + 1, r, p, v); update(u);&#125;void rever(const int &amp;u, const int &amp;l, const int &amp;r, const int &amp;L, const int &amp;R)&#123; if(l == L &amp;&amp; r == R)&#123; swap(mx[u][0], mx[u][1]), swap(mn[u][0], mn[u][1]), rev[u] ^= 1; return; &#125; const int mid = l + r &gt;&gt; 1; pushdown(u); if(R &lt;= mid) rever(lch, l, mid, L, R); else if(L &gt; mid) rever(rch, mid + 1, r, L, R); else rever(lch, l, mid, L, mid), rever(rch, mid + 1, r, mid + 1, R); update(u);&#125;Pair query(const int &amp;u, const int &amp;l, const int &amp;r, const int &amp;L, const int &amp;R)&#123; if(l == L &amp;&amp; r == R) return (Pair)&#123;mx[u][1], mn[u][0]&#125;; const int mid = l + r &gt;&gt; 1; pushdown(u); if(R &lt;= mid) return query(lch, l, mid, L, R); if(L &gt; mid) return query(rch, mid + 1, r, L, R); const Pair lp = query(lch, l, mid, L, mid), rp = query(rch, mid + 1, r, mid + 1, R); return (Pair)&#123;max(lp.mx, rp.mx), min(lp.mn, rp.mn)&#125;;&#125;void dfs1(const int &amp;u)&#123; siz[u] = 1; for(register int i = 0; i &lt;= 1; i++) if(ch[u][i]) seni[ch[u][i]] = i, dfs1(ch[u][i]), siz[u] += siz[ch[u][i]];&#125;void dfs2(const int &amp;u)&#123; dfn[u] = ++dfstime, id[dfstime] = u; int hson = 0; for(register int i = 0; i &lt;= 1; i++) if(siz[ch[u][i]] &gt; siz[hson]) hson = ch[u][i]; if(hson) top[hson] = top[u], dfs2(hson); // Don't return, in order to calc dout[u] for(register int i = 0; i &lt;= 1; i++) if(ch[u][i] &amp;&amp; ch[u][i] != hson) top[ch[u][i]] = ch[u][i], dfs2(ch[u][i]); dout[u] = dfstime;&#125;inline Pair query(int u)&#123; register Pair res = (Pair)&#123;-inf, inf&#125;, cur; while(u)&#123; cur = query(1, 1, n, dfn[top[u]], dfn[u]); res = (Pair)&#123;max(res.mx, cur.mx), min(res.mn, cur.mn)&#125;; u = fa[top[u]]; &#125; return res;&#125;int main()&#123; getint(n), getint(m), memset(seni, 0xff, sizeof(seni)); for(register int i = 1; i &lt;= n; i++)&#123; getint(a[i]), getint(ch[i][0]), getint(ch[i][1]); fa[ch[i][0]] = fa[ch[i][1]] = i; &#125; fa[0] = 0; for(register int i = 1; i &lt;= n; i++) if(!fa[i]) &#123;root = i; break;&#125; dfs1(root), top[root] = root, dfs2(root), build(1, 1, n); while(m--)&#123; int opt, u, v; getint(opt), getint(u); if(opt == 1)&#123; getint(v), a[u] = v; if(ch[u][0]) modify(1, 1, n, dfn[ch[u][0]], v); if(ch[u][1]) modify(1, 1, n, dfn[ch[u][1]], v); &#125; else if(opt == 2)&#123; if(dfn[u] &gt;= dout[u]) continue; rever(1, 1, n, dfn[u] + 1, dout[u]); &#125; else&#123; register Pair res = query(u); puts(a[u] &gt; res.mx &amp;&amp; a[u] &lt; res.mn ? "YES" : "NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1225NOI模拟赛]operation(差分+前缀和+hash)]]></title>
    <url>%2F2018%2F12%2F26%2FEZOI-1225NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-operation-%E5%B7%AE%E5%88%86-%E5%89%8D%E7%BC%80%E5%92%8C-hash%2F</url>
    <content type="text"><![CDATA[§ 1 题意给出一个长度为 $n$ 的 $01$ 序列以及一个正整数 $k$，有 $m$ 次询问，每次给出一个区间 $[l,r]$，你可以进行若干次操作，每次选择 $[l,r]$ 的一个长度为 $k$ 的子区间，将子区间上的所有元素取反，询问至少需要多少次操作才能将 $[l,r]$ 内所有元素变成 $0​$。 注意每次询问独立，在一个询问中进行的操作不会影响另一个询问。 $k\leq n\leq 2\times 10^6,\ \ m\leq 5\times 10^5$。 § 2 分析考虑将原数组差分，记差分数组为 $d$（代码中没有储存差分数组）。 容易发现，将原数组 $[i,i+k-1]$ 上的元素取反，相当于将 $d_i$ 和 $d_{i+k}$ 取反。 若此时 $d_i$ 和 $d_{i+k}$ 均为 $1$，则我们可以视为两者同时消掉。 进一步发现，在 $d$ 数组中，${\rm mod}\ k$ 不相等的下标相互独立，可以分开考虑。 对于 $d$ 数组中下标 ${\rm mod}\ k$ 相等的 $1$，显然将相邻两个 $1$ 消掉操作数最少。 然而题目中 $k$ 的范围过大，若按 ${\rm mod}\ k$ 分组处理后合并，则复杂度与暴力同阶。 首先考虑如何快速判断无解情况。以下分析均忽略边界情况。 我们考虑 ${\rm hash}$，对每一组随机加权，用 ${\rm rnd}_i\ (0\leq i\lt k)$ 表示 ${\rm mod}\ k=i$ 的组的权值。 考虑到区间 $[l,r]$ 无解当且仅当 $[l,r]$ 中有奇数个下标 ${\rm mod}\ k$ 相同的 $1$。 维护前缀异或和 ${\rm xs}_n=\bigoplus\limits_{i=1}^n{\rm rnd}_i$，若 ${\rm xs}_r\oplus{\rm xs}_l\neq 0$ 则一定无解。 然后考虑如何快速计算答案。 考虑到每一组的 $1$ 的贡献正负交替，将前缀和计算式的符号改为 $-$ 即可。 最后注意边界处理下标 $l$ 和 $r+1$，防止将数组化为全 $1$ 而非全 $0$。 总时间复杂度为 $O(n+k+m)$。 § 3 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAXN 2000005using namespace std;typedef long long ll;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, k, m, rnd[MAXN], xs[MAXN], f[MAXN], a[MAXN], b[MAXN], c[MAXN];char s[MAXN];int main()&#123; srand(19260817), getint(n), getint(k), getint(m), scanf("%s", s + 1), s[0] = '0'; for(register int i = 0; i &lt; k; i++) rnd[i] = ((ll)rand() &lt;&lt; 15) ^ rand(); for(register int i = 2; i &lt;= n; i++)&#123; xs[i] = xs[i - 1], f[i] = f[i - 1]; if(s[i] != s[i - 1]) xs[i] ^= rnd[i % k], f[i] += i - (a[i % k] &lt;&lt; 1), a[i % k] = i - a[i % k]; b[i] = a[i % k], c[i] = a[(i + 1) % k]; // 边界处理时使用 &#125; while(m--)&#123; int l, r; getint(l), getint(r); int nosol = xs[l] ^ xs[r], ans = f[r] - f[l]; if(s[l] == '1') nosol ^= rnd[l % k], ans -= l - (b[l] &lt;&lt; 1); if(s[r] == '1') nosol ^= rnd[(r + 1) % k], ans += r + 1 - (c[r] &lt;&lt; 1); printf("%d\n", nosol ? -1 : ans / k); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>差分</tag>
        <tag>前缀和</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈FWT]]></title>
    <url>%2F2018%2F12%2F24%2F%E6%B5%85%E8%B0%88FWT%2F</url>
    <content type="text"><![CDATA[§ 1 前言对于离散卷积式 \begin{align} c_n=\sum\limits_{i+j=n}a_ib_j \end{align}我们可以直接使用 $\rm FFT$ 求解。 考虑该问题的扩展，如何求解将 $i+j=n$ 限制中的 $+$ 换成其他运算符的卷积式。 对于 $c_n=\sum\limits_{i-j=n}a_ib_j$，可以将多项式 $B$ 系数反转后进行 $\rm FFT$。 对于 $c_n=\sum\limits_{i\times j=n} a_ib_j$，在模 $p$ 意义下，且 $p$ 有原根 $G$ 时可以将 $i$ 位置的值放到 $\log_G i\pmod{p}$ 位置进行 $\rm NTT$，然后再放回来。 而对于位运算卷积，即 \left\lbrace \begin{aligned} c_n=\sum\limits_{i\&j=n}a_ib_j \\ c_n=\sum\limits_{i\,|\,j=n}a_ib_j \\ c_n=\sum\limits_{i\oplus j=n}a_ib_j \end{aligned} \right.可以使用快速沃尔什变换 $(\rm Fast\ Walsh\ Transform,\ FWT)$ 求解。 § 2 快速沃尔什变换首先声明下文中用到的表示法。 对于一个 $n-1$ 次多项式 \begin{align} f(x)=a_0x^0+a_1x^1+a_2x^2+\cdots+a_{n-1}x^{n-1} \end{align}将其表示为 \begin{align} (a_0,a_1,a_2,\cdots,a_{n-1}) \end{align}定义多项式加法 $(\rm operator\ +)$ 为 \begin{align} C(x)&=A(x)+B(x) \\ &=(a_0,\ a_1,\ a_2,\cdots,\ a_{n-1})+(b_0,\ b_1,\ b_2,\cdots,\ b_{n-1}) \\ &=(a_0+b_0,\ a_1+b_1,\ a_2+b_2,\cdots,\ a_{n-1}+b_{n-1}) \end{align}定义多项式减法 $(\rm operator\ -)$ 为 \begin{align} C(x)&=A(x)-B(x) \\ &=(a_0,\ a_1,\ a_2,\cdots,\ a_{n-1})-(b_0,\ b_1,\ b_2,\cdots,\ b_{n-1}) \\ &=(a_0-b_0,\ a_1-b_1,\ a_2-b_2,\cdots,\ a_{n-1}-b_{n-1}) \end{align}定义多项式对应系数乘法 $(\rm operator\ \times)$ 为 \begin{align} C(x)&=A(x)\times B(x) \\ &=(a_0,\ a_1,\ a_2,\cdots,\ a_{n-1})\times(b_0,\ b_1,\ b_2,\cdots,\ b_{n-1}) \\ &=(a_0b_0,\ a_1b_1,\ a_2b_2,\cdots,\ a_{n-1}b_{n-1}) \end{align}对于一个位运算符 $\boxtimes\in\lbrace\ |,\ \&amp;,\oplus\rbrace$，定义位运算卷积 \begin{align} C(x)&=A(x)\boxtimes B(x) \\ &=(a_0,\ a_1,\ a_2,\cdots,\ a_{n-1})\boxtimes(b_0,\ b_1,\ b_2,\cdots,\ b_{n-1}) \\ &=(\sum\limits_{i\boxtimes j=0}a_ib_j,\sum\limits_{i\boxtimes j=1}a_ib_j,\sum\limits_{i\boxtimes j=2}a_ib_j,\cdots,\sum\limits_{i\boxtimes j=n-1}a_ib_j) \end{align}易证得，$\boxtimes$ 运算具有分配律。 定义多项式拼接运算 $(A,B)$ 为 \begin{align} (A,B)&=((a_0,\ a_1,\ a_2,\cdots,\ a_{n-1}),(b_0,\ b_1,\ b_2,\cdots,\ b_{n-1})) \\ &=(a_0,\ a_1,\ a_2,\cdots,\ a_{n-1},b_0,\ b_1,\ b_2,\cdots,\ b_{n-1}) \end{align}对于一个 $2^k-1$ 次的多项式 $A$，令 $A_0$ 为其前 $2^{k-1}$ 项，$A_1$ 为其后 $2^{k-1}$ 项。 代码中出现的常量、变量及函数定义如下： 12345typedef long long ll;const int inv2 = 499122177, MOD = 998244353;inline int add(const int &amp;x, const int &amp;y) &#123;return x + y &gt;= MOD ? x + y - MOD : x + y;&#125;inline int mul(const int &amp;x, const int &amp;y) &#123;return x * (ll)y % MOD;&#125; § 2.1 按位或卷积§ 2.1.1 构造按位或卷积形式如下 \begin{align} C&=A\ |\ B \\ \Longleftrightarrow c_n&=\sum\limits_{i\,|\,j=n}a_ib_j \end{align}定义 ${\rm FWT}(A)$ 为 \begin{align} {\rm FWT}(A)=(\sum\limits_{i\,|\,0=0}a_i,\sum\limits_{i\,|\,1=1}a_i,\sum\limits_{i\,|\,2=2}a_i,\cdots,\sum\limits_{i\,|\,(n-1)=(n-1)}a_i) \end{align}容易发现 ${\rm FWT}(A\ |\ B)={\rm FWT}(A)\times{\rm FWT}(B)$，证明如下 \begin{align} {\rm FWT}(A)\times{\rm FWT}(B)&=(\sum\limits_{i\,|\,0=0}a_i,\sum\limits_{i\,|\,1=1}a_i,\cdots,\sum\limits_{i\,|\,(n-1)=(n-1)}a_i)\times(\sum\limits_{i\,|\,0=0}b_i,\sum\limits_{i\,|\,1=1}b_i,\cdots,\sum\limits_{i\,|\,(n-1)=(n-1)}b_i) \\ &=(\sum\limits_{i\,|\,0=0}a_i\sum\limits_{j\,|\,0=0}b_j,\sum\limits_{i\,|\,1=1}a_i\sum\limits_{j\,|\,1=1}b_j,\cdots,\sum\limits_{i\,|\,(n-1)=(n-1)}a_i\sum\limits_{j\,|\,(n-1)=(n-1)}b_j) \\ &=(\sum\limits_{i\,|\,j\,|\,0=0}a_ib_j,\sum\limits_{i\,|\,j\,|\,1=1}a_ib_j,\cdots,\sum\limits_{i\,|\,j\,|\,(n-1)=(n-1)}a_ib_j \\ &=(\sum\limits_{k\,|\,0=0}\sum\limits_{i\,|\,j=k}a_ib_j,\sum\limits_{k\,|\,1=1}\sum\limits_{i\,|\,j=k}a_ib_j,\cdots,\sum\limits_{k\,|\,(n-1)=(n-1)}\sum\limits_{i\,|\,j=k}a_ib_j \\ &={\rm FWT}(A\ |\ B) \end{align}所以我们只需寻找 $A\Leftrightarrow{\rm FWT}(A)$ 之间快速变换的方法即可计算出卷积。 § 2.1.2 快速变换容易发现，对于一个 $2^n-1$ 次多项式 $A$，有如下结论 对于 ${\rm FWT}(A)_0$，只有 ${\rm FWT}(A_0)$ 的对应项有贡献。 对于 ${\rm FWT}(A)_1$，${\rm FWT}(A_0)$ 及 ${\rm FWT}(A_1)$ 的对应项均有贡献。 所以有 {\rm FWT}(A)=\left\lbrace\begin{aligned} &A\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad ,n=1 \\ &({\rm FWT}(A_0),\ {\rm FWT}(A_1)+{\rm FWT}(A_0))\quad,n\neq 1 \end{aligned}\right.{\rm IFWT}(A)=\left\lbrace\begin{aligned} &A\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad,n=1 \\ &({\rm IFWT}(A_0),\ {\rm IFWT}(A_1)-{\rm IFWT}(A_0))\quad,n\neq 1 \end{aligned}\right.12345678910111213inline void FWT_or(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++) A[j + k + i] = add(A[j + k + i] , A[j + k]);&#125;inline void IFWT_or(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++) A[j + k + i] = add(A[j + k + i] , MOD - A[j + k]);&#125; § 2.2 按位与卷积按位与卷积形式如下 \begin{align} C&=A\ \&\ B \\ \Longleftrightarrow c_n&=\sum\limits_{i\&j=n}a_ib_j \end{align}\begin{align} {\rm FWT}(A)=(\sum\limits_{i\&0=0}a_i,\sum\limits_{i\&1=1}a_i,\sum\limits_{i\&2=2}a_i,\cdots,\sum\limits_{i\&(n-1)=(n-1)}a_i) \end{align}处理方式和按位或卷积基本相同，下面直接给出结论 {\rm FWT}(A)=\left\lbrace\begin{aligned} &A\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad ,n=1 \\ &({\rm FWT}(A_0)+{\rm FWT}(A_1),\ {\rm FWT}(A_1))\quad,n\neq 1 \end{aligned}\right.{\rm IFWT}(A)=\left\lbrace\begin{aligned} &A\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad,n=1 \\ &({\rm IFWT}(A_0)-{\rm IFWT}(A_1),\ {\rm IFWT}(A_1))\quad,n\neq 1 \end{aligned}\right.12345678910111213inline void FWT_and(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++) A[j + k] = add(A[j + k] , A[j + k + i]);&#125;inline void IFWT_and(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++) A[j + k] = add(A[j + k] , MOD - A[j + k + i]);&#125; § 2.3 按位异或卷积按位异或卷积形式如下 \begin{align} C&=A\oplus B \\ \Longleftrightarrow c_n&=\sum\limits_{i\oplus j=n}a_ib_j \end{align}\begin{align} {\rm FWT}(A)=(\sum\limits_{i\oplus 0=0}a_i,\sum\limits_{i\oplus 1=1}a_i,\sum\limits_{i\oplus 2=2}a_i,\cdots,\sum\limits_{i\oplus (n-1)=(n-1)}a_i) \end{align}处理方式和前两个位运算卷积基本相同，证明见 zyh 巨爷的博文，下面直接给出结论 {\rm FWT}(A)=\left\lbrace\begin{aligned} &A\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad\ \ ,n=1 \\ &({\rm FWT}(A_0)+{\rm FWT}(A_1),\ {\rm FWT}(A_0)-{\rm FWT}(A_1))\quad,n\neq 1 \end{aligned}\right.{\rm IFWT}(A)=\left\lbrace\begin{aligned} &A\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\ \ ,n=1 \\ &\left(\frac{ {\rm IFWT}(A_0)+{\rm IFWT}(A_1)}{2},\ \frac{ {\rm IFWT}(A_0)-{\rm IFWT}(A_1)}{2}\right)\quad,n\neq 1 \end{aligned}\right.123456789101112131415161718inline void FWT_xor(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++)&#123; const int L = A[j + k], R = A[j + k + i]; A[j + k] = add(L, R), A[j + k + i] = add(L, MOD - R); &#125;&#125;inline void IFWT_xor(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++)&#123; const int L = A[j + k], R = A[j + k + i]; A[j + k] = add(L, R), A[j + k + i] = add(L, MOD - R); A[j + k] = mul(A[j + k], inv2), A[j + k + i] = mul(A[j + k + i], inv2); &#125;&#125; § 3 模板题=&gt; luogu 4717 【模板】快速沃尔什变换§ 3.1 题意给定长度为 $2^n$ 的两个多项式 $A,\ B$，设 $C_i=\sum\limits_{j\boxtimes k=i}A_jB_k$。 求出当 $\boxtimes$ 分别为 ${\rm or},\ {\rm and},\ {\rm xor}$ 时的 $C$。 $0\leq n\leq 17$。 § 3.2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int inv2 = 499122177, MOD = 998244353;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;inline int add(const int &amp;x, const int &amp;y) &#123;return x + y &gt;= MOD ? x + y - MOD : x + y;&#125;inline int mul(const int &amp;x, const int &amp;y) &#123;return x * (ll)y % MOD;&#125;int n, lim, A[131080], B[131080], C[131080];inline void FWT_or(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++) A[j + k + i] = add(A[j + k + i] , A[j + k]);&#125;inline void IFWT_or(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++) A[j + k + i] = add(A[j + k + i] , MOD - A[j + k]);&#125;inline void FWT_and(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++) A[j + k] = add(A[j + k] , A[j + k + i]);&#125;inline void IFWT_and(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++) A[j + k] = add(A[j + k] , MOD - A[j + k + i]);&#125;inline void FWT_xor(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++)&#123; const int L = A[j + k], R = A[j + k + i]; A[j + k] = add(L, R), A[j + k + i] = add(L, MOD - R); &#125;&#125;inline void IFWT_xor(int *A)&#123; for(register int i = 1; i &lt; lim; i &lt;&lt;= 1) for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = 0; k &lt; i; k++)&#123; const int L = A[j + k], R = A[j + k + i]; A[j + k] = add(L, R), A[j + k + i] = add(L, MOD - R); A[j + k] = mul(A[j + k], inv2), A[j + k + i] = mul(A[j + k + i], inv2); &#125;&#125;int main()&#123; getint(n), lim = 1 &lt;&lt; n; for(register int i = 0; i &lt; lim; i++) getint(A[i]); for(register int i = 0; i &lt; lim; i++) getint(B[i]); FWT_or(A), FWT_or(B); for(register int i = 0; i &lt; lim; i++) C[i] = mul(A[i], B[i]); IFWT_or(A), IFWT_or(B), IFWT_or(C); for(register int i = 0; i &lt; lim; i++) printf("%d ", C[i]); puts(""); FWT_and(A), FWT_and(B); for(register int i = 0; i &lt; lim; i++) C[i] = mul(A[i], B[i]); IFWT_and(A), IFWT_and(B), IFWT_and(C); for(register int i = 0; i &lt; lim; i++) printf("%d ", C[i]); puts(""); FWT_xor(A), FWT_xor(B); for(register int i = 0; i &lt; lim; i++) C[i] = mul(A[i], B[i]); IFWT_xor(C); for(register int i = 0; i &lt; lim; i++) printf("%d ", C[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈多项式]]></title>
    <url>%2F2018%2F12%2F24%2F%E6%B5%85%E8%B0%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[§ 1 多项式基本操作 多项式乘法 多项式求逆 多项式除法/取模 多项式开根 多项式 $\ln$ 多项式 $\exp$ 多项式 $k$ 次幂 为简化运算，所有操作均在 ${\rm mod}\ 998244353$ 意义下进行。实现时注意清空高次系数。 代码中出现的常量、变量及函数定义如下： 123456789101112131415typedef long long ll;typedef struct &#123;int r, i;&#125; Pair;const int G = 3, MOD = 998244353;int lim, invlim, s, Wn[1 &lt;&lt; 18], rev[1 &lt;&lt; 18];inline int add(const int &amp;x, const int &amp;y) &#123;return x + y &lt; MOD ? x + y : x + y - MOD;&#125;inline int sub(const int &amp;x, const int &amp;y) &#123;return x &gt;= y ? x - y : x - y + MOD;&#125;inline int mul(const int &amp;x, const int &amp;y) &#123;return x * (ll)y % MOD;&#125;inline int getrand(const int &amp;mx) &#123;return (((ll)rand() &lt;&lt; 15) ^ rand()) % mx + 1;&#125;inline int fastpow(int bas, int ex = MOD - 2)&#123; register int res = 1; bas %= MOD; for(; ex; ex &gt;&gt;= 1, bas = mul(bas, bas)) if(ex &amp; 1) res = mul(res, bas); return res;&#125; § 1.1 多项式乘法直接 $\rm NTT$ 求卷积。 时间复杂度 $O(n\log n)$。 123456789101112131415161718192021222324252627282930inline void init(const int &amp;n)&#123; lim = 1, s = 0; while(lim &lt; n) lim &lt;&lt;= 1, s++; invlim = fastpow(lim); for(register int i = 1; i &lt; lim; i++) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (s - 1);&#125;inline void NTT(vector&lt;int&gt; &amp;a, int f)&#123; a.resize(lim); for(register int i = 1; i &lt; lim; i++) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(register int i = 1; i &lt; lim; i &lt;&lt;= 1)&#123; Wn[0] = 1, Wn[1] = fastpow(G, (MOD - 1) / (i &lt;&lt; 1)); for(register int j = 2; j &lt; i; j++) Wn[j] = mul(Wn[j - 1], Wn[1]); for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = j; k &lt; j + i; k++)&#123; const int t = mul(Wn[k - j], a[k + i]); a[k + i] = sub(a[k], t), a[k] = add(a[k], t); &#125; &#125; if(f == -1)&#123; reverse(a.begin() + 1, a.end()); for(auto &amp;i: a) i = mul(i, invlim); &#125;&#125;inline vector&lt;int&gt; polymul(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; vector&lt;int&gt; A(a), B(b); init(a.size() + b.size() - 1); NTT(A, 1), NTT(B, 1); for(register int i = 0; i &lt; lim; i++) A[i] = mul(A[i], B[i]); NTT(A, -1); return A.resize(a.size() + b.size() - 1), A;&#125; § 1.2 多项式求逆给定多项式 $A(x)$，求 $A^{-1}(x)$ 满足 \begin{align} A(x)A^{-1}(x)\equiv 1\pmod{x^n} \end{align}其中 ${\rm mod}\ x^n$ 表示保留 $0\sim n-1$ 次项。 当 $n=1$ 时，直接用费马小定理得 $a^{-1}\equiv a^{p-2}\pmod{p}$。 当 $n\gt 1$ 时，假设当前已求出 ${\rm mod}\ x^{\lceil\frac{n}{2}\rceil}$ 意义下的 $A(x)$ 的逆元 $B_0(x)$，即 \begin{align} A(x)B_0(x)\equiv 1\pmod{x^{\lceil\frac{n}{2}\rceil}} \end{align}需要求出 $B(x)$ 满足 \begin{align} A(x)B(x)\equiv 1\pmod{x^n} \end{align}两式相减得 \begin{align} A(x)(B(x)-B_0(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}} \end{align}考虑到 $A(x)\not\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}$，故有 \begin{align} B(x)-B_0(x)\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}} \end{align}两边平方，考虑卷积定义，可知同余式右边仍为 $0$，即 \begin{align} B^2(x)-2B(x)B_0(x)+B_0^2(x)\equiv 0\pmod{x^n} \end{align}两边同乘 $A(x)$ 得 \begin{align} B(x)-2B_0(x)+A(x)B_0^2(x)\equiv 0\pmod{x^n} \end{align}化简得 \begin{align} B(x)\equiv B_0(x)(2-A(x)B_0(x))\pmod{x^n} \end{align}递归求解即可，时间复杂度为 $T(n)=T(\frac{n}{2})+O(n\log n)=O(n\log n)$。 123456789inline vector&lt;int&gt; polyinv(const vector&lt;int&gt; &amp;a, int n = -1)&#123; if(n == -1) n = a.size(); vector&lt;int&gt; inv, A(a.begin(), a.begin() + n); if(n == 1) return inv.push_back(fastpow(a[0])), inv; inv = polyinv(a, n + 1 &gt;&gt; 1), init((n &lt;&lt; 1) - 1); NTT(inv, 1), NTT(A, 1); for(register int i = 0; i &lt; lim; i++) inv[i] = mul(inv[i], sub(2, mul(inv[i], A[i]))); NTT(inv, -1); return inv.resize(n), inv;&#125; § 1.3 多项式除法/取模给定 $n-1$ 次多项式 $A(x)$ 和 $m-1$ 次多项式 $B(x)$，求多项式 $D(x),\ R(x)$ 满足 \begin{align} A(x)&=D(x)B(x)+R(x) \\ \Longrightarrow A(x)&\equiv R(x)\pmod{B(x)} \end{align}其中 $D(x)$ 为 $n-m$ 次，$R(x)$ 至多 $m-2$ 次。 由于该式的余数 $R(x)$ 难以处理，考虑去除其影响。 定义 $A(x)$ 的系数反转多项式 $A^R(x)$ 为 \begin{align} A^R(x)&=\sum\limits_{i=0}^{n-1}a_{n-i-1}x^i \\ &=x^{n-1}A(\frac{1}{x}) \end{align}则有 \begin{align} A^R(x)&=x^{n-1}A(\frac{1}{x}) \\ &=x^{n-m}D(\frac{1}{x})·x^{m-1}B(\frac{1}{x})+x^{n-m+1}·x^{m-2}R(\frac{1}{x}) \\ &=D^R(x)B^R(x)+x^{n-m+1}R^R(x) \\ &\equiv D^R(x)B^R(x)\pmod{x^{n-m+1}} \end{align}所以可在 ${\rm mod}\ x^{n-m+1}$ 意义下求逆得到 $D^R(x)$，反转即为 $D(x)$，然后代入原式计算 $R(x)$。 共需要一次求逆和两次乘法，时间复杂度为 $O(n\log n)$。 12345678910inline void polydiv(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b, vector&lt;int&gt; &amp;d, vector&lt;int&gt; &amp;r)&#123; if(b.size() &gt; a.size()) return r = a, d.clear(); vector&lt;int&gt; A(a), B(b), invB; int n = a.size(), m = b.size(); reverse(A.begin(), A.end()), reverse(B.begin(), B.end()); B.resize(n - m + 1), invB = polyinv(B, n - m + 1); d = polymul(A, invB), d.resize(n - m + 1), reverse(d.begin(), d.end()); r = polymul(b, d); for(register int i = 0; i &lt; m - 1; i++) r[i] = sub(a[i], r[i]); r.resize(m - 1);&#125; § 1.π 多项式牛顿迭代法该方法可以用来推很多公式，如多项式求逆、开根以及 $\exp$ 等。 给出一个关于多项式 $f(x)$ 的方程 $g(f(x))=0$，假设已求出 $f(x)$ 的前 $n$ 项 $f_0(x)$，即 \left\lbrace \begin{aligned} f(x)\equiv f_0(x)&\pmod{x^n} \\ g(f_0(x))\equiv 0&\pmod{x^n} \end{aligned} \right.将函数 $g(f(x))$ 在 $f_0(x)$ 上泰勒展开得 \begin{align} g(f(x))=g(f_0(x))+\frac{g'(f_0(x))}{1!}(f(x)-f_0(x))^1+\frac{g''(f_0(x))}{2!}(f(x)-f_0(x))^2+\cdots\cdots \end{align}注意到 $f(x)-f_0(x)$ 第 $0\sim n-1$ 项为 $0$，故 $(f(x)-f_0(x))^2$ 第 $0\sim 2n-1$ 项为 $0$，于是有 \begin{align} g(f(x))\equiv g(f_0(x))+g'(f_0(x))(f(x)-f_0(x))\equiv 0\pmod{x^{2n}} \end{align}化简得 \begin{align} f(x)\equiv f_0(x)-\frac{g(f_0(x))}{g'(f_0(x))}\pmod{x^{2n}} \end{align}运用一次该公式即可将 $f(x)$ 的已知项数翻倍。 § 1.4 多项式开根给定多项式 $A(x)$，求 $B(x)=\sqrt{A(x)}$ 满足 \begin{align} B^2(x)-A(x)\equiv 0\pmod{x^n} \end{align}令 $B(x)\equiv B_0(x)\pmod{x^n}$，直接运用牛顿迭代法得 \begin{align} B(x)&\equiv B_0(x)-\frac{B_0^2(x)-A(x)}{2B_0(x)}\pmod{x^{2n}} \\ &\equiv \frac{1}{2}\left(B_0(x)+\frac{A(x)}{B_0(x)}\right)\pmod{x^{2n}} \end{align}若 $A(x)$ 的常数项不够优秀，递归到边界时还需用 ${\rm Cipolla}$ 算法计算二次剩余，见 T 老师的博文。 时间复杂度为 $T(n)=T(\frac{n}{2})+O(n\log n)=O(n\log n)$。 12345678910111213141516171819202122inline Pair pmul(const Pair &amp;a, const Pair &amp;b, int t)&#123; return (Pair)&#123; add(mul(a.r, b.r), mul(mul(a.i, b.i), t)), add(mul(a.r, b.i), mul(a.i, b.r)) &#125;;&#125;inline int quadres(const int &amp;a)&#123; // 计算二次剩余 (Quadratic residue) if(a == 1) return 1; if(fastpow(a, MOD - 1 &gt;&gt; 1) != 1) return -1; int x, t; do x = getrand(a - 1); while(fastpow(t = sub(mul(x, x), a), MOD - 1 &gt;&gt; 1) == 1); Pair res = (Pair)&#123;1, 0&#125;, bas = (Pair)&#123;x, 1&#125;; for(register int ex = MOD + 1 &gt;&gt; 1; ex; ex &gt;&gt;= 1, bas = pmul(bas, bas, t)) if(ex &amp; 1) res = pmul(res, bas, t); return min(res.r, MOD - res.r);&#125;inline vector&lt;int&gt; polysqrt(const vector&lt;int&gt; &amp;a, int n = -1)&#123; if(n == -1) n = a.size(); vector&lt;int&gt; s, A(a.begin(), a.begin() + n); if(n == 1) return s.push_back(quadres(a[0])), s; s = polysqrt(a, n + 1 &gt;&gt; 1), s.resize(n), A = polymul(A, polyinv(s)); for(register int i = 0; i &lt; n; i++) s[i] = add(s[i], A[i]); for(auto &amp;i: s) i = (i &amp; 1 ? i + MOD &gt;&gt; 1 : i &gt;&gt; 1); return s;&#125; § 1.5 多项式 $\ln$给定多项式 $A(x)$，求 \begin{align} \ln A(x)\pmod{x^n} \end{align}考虑直接计算 \begin{align} \ln A(x)&=\int(\ln A(x))' \\ &=\int\frac{A'(x)}{A(x)} \end{align}其中求导和积分都可以在 $O(n)$ 的时间内完成。 代码中省略了预处理逆元的步骤，故积分的复杂度为 $O(n\log n)$。 注意需要保证 $A(x)$ 常数项为 $1$，且默认 $\ln A(x)$ 的常数项为 $0$。 共需要一次求逆，时间复杂度为 $O(n\log n)$。 12345678910111213141516inline vector&lt;int&gt; polyderiv(const vector&lt;int&gt; &amp;a)&#123; vector&lt;int&gt; deriv(a.size() - 1); for(register int i = 1; i &lt; a.size(); i++) deriv[i - 1] = mul(a[i], i); return deriv;&#125;inline vector&lt;int&gt; polyintegr(const vector&lt;int&gt; &amp;a)&#123; vector&lt;int&gt; integr(a.size() + 1); for(register int i = 0; i &lt; a.size(); i++) integr[i + 1] = mul(a[i], fastpow(i + 1)); return integr;&#125;inline vector&lt;int&gt; polyln(const vector&lt;int&gt; &amp;a)&#123; vector&lt;int&gt; l = polymul(polyderiv(a), polyinv(a)); return l.resize(a.size() - 1), polyintegr(l);&#125; § 1.6 多项式 $\exp$给定多项式 $A(x)$，求 \begin{align} e^{A(x)}\pmod{x^n} \end{align}令 $B(x)=e^{A(x)}\pmod{x^n}$，两边取对数得 \begin{align} \ln B(x)-A(x)\equiv 0\pmod{x^n} \end{align}然后令 $B(x)\equiv B_0(x)\pmod{x^n}$，运用牛顿迭代法得 \begin{align} B(x)&\equiv B_0(x)-\frac{\ln B(x)-A(x)}{\frac{1}{B(x)}}\pmod{x^{2n}} \\ \Longrightarrow B(x)&\equiv B_0(x)(1+A(x)-\ln B_0(x))\pmod{x^{2n}} \end{align}注意需要保证 $A(x)$ 常数项为 $0$，且默认 $e^{A(x)}$ 的常数项为 $1$。 时间复杂度为 $T(n)=T(\frac{n}{2})+O(n\log n)=O(n\log n)$。 12345678inline vector&lt;int&gt; polyexp(const vector&lt;int&gt; &amp;a, int n = -1)&#123; if(n == -1) n = a.size(); vector&lt;int&gt; e, A; if(n == 1) return e.push_back(1), e; e = polyexp(a, n + 1 &gt;&gt; 1), e.resize(n), A = polyln(e); for(register int i = 0; i &lt; n; i++) A[i] = sub(a[i], A[i]); A[0] = add(A[0], 1), e = polymul(e, A); return e.resize(n), e;&#125; § 1.7 多项式 $k$ 次幂给定多项式 $A(x)$ 和正整数 $k$，求 \begin{align} f^k(x)\pmod{x^n} \end{align}直接快速幂，时间复杂度为 $O(n\log n\log k)$。 当 $f(x)$ 的常数项为 $1$ 时，有 \begin{align} f^k(x)=e^{k\ln f(x)} \end{align}时间复杂度为 $O(n\log n)$。 当 $f(x)$ 的常数项不为 $1$ 时，设 $f(x)$ 的最低次项为 $ax^d$，则将其提出 \begin{align} f^k(x)=a^kx^{dk}\left(\frac{f(x)}{ax^d}\right)^k \end{align}可以平移幂次处理后用上面的公式计算，时间复杂度为 $O(n\log n)$。 代码只给出 $f(x)$ 常数项为 $1$ 的情况。 12345inline vector&lt;int&gt; polypow(const vector&lt;int&gt; &amp;a, const int &amp;ex)&#123; vector&lt;int&gt; p = polyln(a); for(int &amp;i: p) i = mul(i, ex); return polyexp(p);&#125; § 2 模板题=&gt; LibreOJ #150 挑战多项式§ 2.1 题意给定一个 $n+1$ 次多项式 $F(x)$ 和一个正整数 $k$，求多项式 $G(x)$ 满足 \begin{align} G(x)\equiv\left(\left(1+\ln\left(2+F(x)-F(0)-\exp\left(\int\frac{1}{\sqrt{F(x)}}\ {\rm d}x\right)\right)\right)^k\right)'\pmod{x^n} \end{align}保证 $F(x)$ 的常数项是 ${\rm mod}\ 998244353$ 的二次剩余。 注意到开根时 $\pm\sqrt{F(x)}$ 均为合法解，只需取常数项较小者计算即可。 所有运算在 ${\rm mod}\ 998244353$ 下进行。 $1\leq n\leq 10^5,\ \ 0\leq k\lt 998244353$。 § 2.2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define MAXN (1 &lt;&lt; 18)using namespace std;typedef long long ll;template &lt;typename T&gt; inline void getint(T &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;namespace Poly&#123; typedef struct &#123;int r, i;&#125; Pair; const int G = 3, MOD = 998244353; int lim, invlim, s, Wn[MAXN], rev[MAXN]; inline int add(const int &amp;x, const int &amp;y) &#123;return x + y &lt; MOD ? x + y : x + y - MOD;&#125; inline int sub(const int &amp;x, const int &amp;y) &#123;return x &gt;= y ? x - y : x - y + MOD;&#125; inline int mul(const int &amp;x, const int &amp;y) &#123;return x * (ll)y % MOD;&#125; inline int getrand(const int &amp;mx) &#123;return (((ll)rand() &lt;&lt; 15) ^ rand()) % mx + 1;&#125; inline int fastpow(int bas, int ex = MOD - 2)&#123; register int res = 1; bas %= MOD; for(; ex; ex &gt;&gt;= 1, bas = mul(bas, bas)) if(ex &amp; 1) res = mul(res, bas); return res; &#125; inline Pair pmul(const Pair &amp;a, const Pair &amp;b, int t)&#123; return (Pair)&#123; add(mul(a.r, b.r), mul(mul(a.i, b.i), t)), add(mul(a.r, b.i), mul(a.i, b.r)) &#125;; &#125; inline int quadres(const int &amp;a)&#123; if(a == 1) return 1; if(fastpow(a, MOD - 1 &gt;&gt; 1) != 1) return -1; int x, t; do x = getrand(a - 1); while(fastpow(t = sub(mul(x, x), a), MOD - 1 &gt;&gt; 1) == 1); Pair res = (Pair)&#123;1, 0&#125;, bas = (Pair)&#123;x, 1&#125;; for(register int ex = MOD + 1 &gt;&gt; 1; ex; ex &gt;&gt;= 1, bas = pmul(bas, bas, t)) if(ex &amp; 1) res = pmul(res, bas, t); return min(res.r, MOD - res.r); &#125; inline void init(const int &amp;n)&#123; lim = 1, s = 0; while(lim &lt; n) lim &lt;&lt;= 1, s++; invlim = fastpow(lim); for(register int i = 1; i &lt; lim; i++) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (s - 1); &#125; inline void NTT(vector&lt;int&gt; &amp;a, int f)&#123; a.resize(lim); for(register int i = 1; i &lt; lim; i++) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(register int i = 1; i &lt; lim; i &lt;&lt;= 1)&#123; Wn[0] = 1, Wn[1] = fastpow(G, (MOD - 1) / (i &lt;&lt; 1)); for(register int j = 2; j &lt; i; j++) Wn[j] = mul(Wn[j - 1], Wn[1]); for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = j; k &lt; j + i; k++)&#123; const int t = mul(Wn[k - j], a[k + i]); a[k + i] = sub(a[k], t), a[k] = add(a[k], t); &#125; &#125; if(f == -1)&#123; reverse(a.begin() + 1, a.end()); for(auto &amp;i: a) i = mul(i, invlim); &#125; &#125; inline vector&lt;int&gt; polymul(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; vector&lt;int&gt; A(a), B(b); init(a.size() + b.size() - 1); NTT(A, 1), NTT(B, 1); for(register int i = 0; i &lt; lim; i++) A[i] = mul(A[i], B[i]); NTT(A, -1); return A.resize(a.size() + b.size() - 1), A; &#125; inline vector&lt;int&gt; polyinv(const vector&lt;int&gt; &amp;a, int n = -1)&#123; if(n == -1) n = a.size(); vector&lt;int&gt; inv, A(a.begin(), a.begin() + n); if(n == 1) return inv.push_back(fastpow(a[0])), inv; inv = polyinv(a, n + 1 &gt;&gt; 1), init((n &lt;&lt; 1) - 1); NTT(inv, 1), NTT(A, 1); for(register int i = 0; i &lt; lim; i++) inv[i] = mul(inv[i], sub(2, mul(inv[i], A[i]))); NTT(inv, -1); return inv.resize(n), inv; &#125; inline void polydiv(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b, vector&lt;int&gt; &amp;d, vector&lt;int&gt; &amp;r)&#123; if(b.size() &gt; a.size()) return r = a, d.clear(); vector&lt;int&gt; A(a), B(b), invB; int n = a.size(), m = b.size(); reverse(A.begin(), A.end()), reverse(B.begin(), B.end()); B.resize(n - m + 1), invB = polyinv(B, n - m + 1); d = polymul(A, invB), d.resize(n - m + 1), reverse(d.begin(), d.end()); r = polymul(b, d); for(register int i = 0; i &lt; m - 1; i++) r[i] = sub(a[i], r[i]); r.resize(m - 1); &#125; inline vector&lt;int&gt; polyderiv(const vector&lt;int&gt; &amp;a)&#123; vector&lt;int&gt; deriv(a.size() - 1); for(register int i = 1; i &lt; a.size(); i++) deriv[i - 1] = mul(a[i], i); return deriv; &#125; inline vector&lt;int&gt; polyintegr(const vector&lt;int&gt; &amp;a)&#123; vector&lt;int&gt; integr(a.size() + 1); for(register int i = 0; i &lt; a.size(); i++) integr[i + 1] = mul(a[i], fastpow(i + 1)); return integr; &#125; inline vector&lt;int&gt; polyln(const vector&lt;int&gt; &amp;a)&#123; vector&lt;int&gt; l = polymul(polyderiv(a), polyinv(a)); return l.resize(a.size() - 1), polyintegr(l); &#125; inline vector&lt;int&gt; polyexp(const vector&lt;int&gt; &amp;a, int n = -1)&#123; if(n == -1) n = a.size(); vector&lt;int&gt; e, A; if(n == 1) return e.push_back(1), e; e = polyexp(a, n + 1 &gt;&gt; 1), e.resize(n), A = polyln(e); for(register int i = 0; i &lt; n; i++) A[i] = sub(a[i], A[i]); A[0] = add(A[0], 1), e = polymul(e, A); return e.resize(n), e; &#125; inline vector&lt;int&gt; polysqrt(const vector&lt;int&gt; &amp;a, int n = -1)&#123; if(n == -1) n = a.size(); vector&lt;int&gt; s, A(a.begin(), a.begin() + n); if(n == 1) return s.push_back(quadres(a[0])), s; s = polysqrt(a, n + 1 &gt;&gt; 1), s.resize(n), A = polymul(A, polyinv(s)); for(register int i = 0; i &lt; n; i++) s[i] = add(s[i], A[i]); for(auto &amp;i: s) i = (i &amp; 1 ? i + MOD &gt;&gt; 1 : i &gt;&gt; 1); return s; &#125; inline vector&lt;int&gt; polypow(const vector&lt;int&gt; &amp;a, const int &amp;ex)&#123; vector&lt;int&gt; p = polyln(a); for(int &amp;i: p) i = mul(i, ex); return polyexp(p); &#125;&#125;int n, k;vector&lt;int&gt; F, G;inline vector&lt;int&gt; solve(const vector&lt;int&gt; &amp;F, const int &amp;k)&#123; using namespace Poly; vector&lt;int&gt; G = polyexp(polyintegr(polyinv(polysqrt(F)))); for(register int i = 1; i &lt; F.size(); i++) G[i] = sub(F[i], G[i]); return G = polyln(G), G[0] = add(G[0], 1), polyderiv(polypow(G, k));&#125;int main()&#123; srand(19260817), getint(n), getint(k), F.resize(n + 1); for(register int i = 0; i &lt;= n; i++) getint(F[i]); G = solve(F, k), G.resize(n); while(*G.rbegin() == 0) G.pop_back(); for(auto i: G) printf("%d ", i); return puts(""), 0;&#125;]]></content>
      <tags>
        <tag>FFT/NTT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈分治FFT]]></title>
    <url>%2F2018%2F12%2F20%2F%E6%B5%85%E8%B0%88%E5%88%86%E6%B2%BBFFT%2F</url>
    <content type="text"><![CDATA[§ 1 例题一=&gt; luogu 4721 【模板】分治 FFT§ 1.1 题意给定长度为 $n-1$ 的数组 $g[1],\ g[2],\cdots,g[n-1]$，求 $f[0],\ f[1],\cdots,\ f[n-1]$，其中 \begin{align} f[i]=\sum\limits_{j=1}^if[i-j]·g[j] \end{align}边界为 $f[0]=1$。答案对 $998244353$ 取模。 $2\leq n\leq 10^5,\ \ 0\leq g[i]\lt 998244353$。 § 1.2 分析令 $P_{\ l,r}$ 表示多项式 $P$ 的第 $l\sim r$ 项系数，即 $P[l],\ P[l+1],\cdots,P[r]$。 观察发现，题目要求的数组 $f$ 类似于卷积，但后面的项与前面有关，不能直接 ${\rm FFT}$。 考虑分治求解，假设已知 $f_{\,l,mid}$，我们需要求出其对 $f_{\,mid+1,r}$ 的贡献。改写定义可得 \begin{align} f[i]&=\sum\limits_{j=1}^if[i-j]·g[j] \\ &=\sum\limits_{j=0}^{i-1}f[j]·g[i-j] \end{align}可以发现左半部分对右半部分贡献为 \begin{align} \sum\limits_{j=l}^{mid}f[j]·g[i-j] \to f[i],\quad i\gt mid \end{align}上式左边可看作 $f_{\,l,mid} \bigotimes g_{\,0,r-l}$（其中 $\bigotimes$ 为卷积符号）。 由于模数为 $998244353$，直接用原根 $G=3$ 的 ${\rm NTT}$ 求解即可。 总时间复杂度为 $O(n\log^2n)$。 § 1.3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Let f[i] = sigma&#123;j = 1 .. i&#125; f[i - j] g[j]// Given g[1 .. n - 1], find f[0 .. n - 1] % 998244353#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int G = 3, MOD = 998244353, MAXN = 262150;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, g[MAXN], f[MAXN];inline int fastpow(int bas, int ex)&#123; register int res = 1; bas %= MOD; while(ex) &#123;if(ex &amp; 1) res = res * (ll)bas % MOD; bas = bas * (ll)bas % MOD, ex &gt;&gt;= 1;&#125; return res;&#125;namespace Poly&#123; int rev[MAXN], lim, invlim, s, Wn[MAXN], a[MAXN], b[MAXN]; #define add(a, b) ((a) + (b) &gt;= MOD ? (a) + (b) - MOD : (a) + (b)) #define minus(a, b) ((a) &lt; (b) ? (a) - (b) + MOD : (a) - (b)) #define mul(a, b) ((a) * ll(b) % MOD) inline void init(const int &amp;n)&#123; lim = 1, s = 0; while(lim &lt; (n &lt;&lt; 1)) lim &lt;&lt;= 1, s++; invlim = fastpow(lim, MOD - 2); for(register int i = 1; i &lt; lim; i++) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (s - 1); &#125; inline void NTT(int *a, int f)&#123; for(register int i = 0; i &lt; lim; i++) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(register int i = 1; i &lt; lim; i &lt;&lt;= 1)&#123; Wn[0] = 1, Wn[1] = fastpow(G, (MOD - 1) / (i &lt;&lt; 1)); for(register int j = 2; j &lt; i; j++) Wn[j] = mul(Wn[j - 1], Wn[1]); for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1)&#123; register int *L = a + j, *R = L + i; for(register int k = 0; k &lt; i; k++)&#123; const int t = mul(Wn[k], R[k]); R[k] = minus(L[k], t), L[k] = add(L[k], t); &#125; &#125; &#125; if(f == -1)&#123; reverse(a + 1, a + lim); for(register int i = 0; i &lt; lim; i++) a[i] = mul(a[i], invlim); &#125; &#125; void cdq(int *f, int *g, int l, int r)&#123; if(l == r) return; const int mid = l + r &gt;&gt; 1; cdq(f, g, l, mid), init(r - l + 1); memset(a, 0, sizeof(int) * lim), memset(b, 0, sizeof(int) * lim); for(register int i = l; i &lt;= mid; i++) a[i - l] = f[i]; for(register int i = 0; i &lt;= r - l; i++) b[i] = g[i]; NTT(a, 1), NTT(b, 1); for(register int i = 0; i &lt; lim; i++) a[i] = mul(a[i], b[i]); NTT(a, -1); for(register int i = mid + 1; i &lt;= r; i++) f[i] = add(f[i], a[i - l]); cdq(f, g, mid + 1, r); &#125;&#125;int main()&#123; getint(n), f[0] = 1; for(register int i = 1; i &lt; n; i++) getint(g[i]); Poly::cdq(f, g, 0, n - 1); for(register int i = 0; i &lt; n; i++) printf("%d ", f[i]); return puts(""), 0;&#125; § 2 例题二=&gt; [EZOI][1217NOI模拟赛]math(生成函数+分治FFT+高精度) 的子问题 § 2.1 子问题求多项式 $\prod\limits_{i=1}^n(x+i)$ 展开后各项的值。 $n\leq 10^5$。 § 2.2 求解分治求解，时间复杂度 $T(n)=2\ T(\frac{n}{2})+O(n\log n)=O(n\log^2n)$。 多项式用 vector 存储处理较方便。代码可参考上方链接博文。]]></content>
      <tags>
        <tag>FFT/NTT</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1217NOI模拟赛]math(生成函数+分治FFT+高精度)]]></title>
    <url>%2F2018%2F12%2F19%2FEZOI-1217NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-math-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E5%88%86%E6%B2%BBFFT-%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[§ 1 题意对于集合 $S$，定义 $P(S)=\prod\limits_{x\in S}x$，即 $S$ 中元素之积。特别地，定义 $P(\emptyset)=1$。 记 $[n]=\lbrace 1,2,3,\cdots,n \rbrace$，对于 $n \in \mathbb{Z},\ 0\leq k\leq n$，定义 $F(n,k)=\sum\limits_{S\subseteq[n],\ |S|=k}P(S)$。 给定 $n​$ 以及质数 $p​$，求存在多少 $[0,n]​$ 上的整数 $k​$ 满足 $p\nmid F(n,k)​$，答案对 $998244353​$ 取模。 $1\leq n\leq 10^{1000},\ \ 2\leq p\leq 10^5$。 § 2 分析由题意可得， $F(n,k)$ 表示从 $1\sim n$ 中选出 $k$ 个相乘的值。考虑其生成函数，显然有 \begin{align} G_n&=\sum\limits_{i=0}^nF(n,i)·x^i \\ &\equiv\prod\limits_{i=1}^n(ix+1)\quad({\rm mod}\ p) \end{align}题目要求满足 $p\nmid F(n,k)$ 的整数 $k$ 的个数，就等价于求生成函数有多少项系数不为 $0$。 为简化计算，我们考虑将上式的高次项和低次项交换，得到 \begin{align} G_n^R\equiv\prod\limits_{i=1}^n(x+i)\quad({\rm mod}\ p) \end{align}该多项式系数不为 $0$ 的项数显然与原多项式相同。 令 $n=a·p+b$，则有 \begin{align} G_n^R\equiv\left(\prod\limits_{i=1}^p(x+i)\right)^a·\prod\limits_{i=1}^b(x+i)\quad({\rm mod}\ p) \end{align}考虑 $\prod\limits_{i=1}^p(x+i)$，可以发现该式在 ${\rm mod}\ p$ 意义下有且仅有 $p$ 个零点：$0,1,\cdots,p-1$。 由费马小定理可得 $x^{p-1}\equiv 1\quad({\rm mod}\ p)\ (0\lt x\lt p)$。 那么我们考虑 $x·(x^{p-1}-1)$，可以发现该式在 ${\rm mod\ p}$ 意义下有且仅有 $p$ 个零点：$0,1,\cdots,p-1$。 又有 $\prod\limits_{i=1}^p(x+i)$ 与 $x·(x^{p-1}-1)$ 都是 $p$ 次多项式，最高次均为 $1$，故能被 $p$ 个不同点确定。 所以 $\prod\limits_{i=1}^p(x+i)\equiv x·(x^{p-1}-1)\quad({\rm mod}\ p)$，于是有 \begin{align} G_n^R\equiv x^a·(x^{p-1}-1)^a·\prod\limits_{i=1}^b(x+i)\quad({\rm mod}\ p) \end{align} 首先考虑 $x^a$，对该项系数是否为 $0$ 无影响。 然后考虑 $(x^{p-1}-1)^a$，用二项式定理展开得 \begin{align} (x^{p-1}-1)^a=\sum\limits_{i=0}^a(-1)^{a-i}·x^{(p-1)·i}·\binom{a}{i} \end{align}发现只有 $\binom{a}{i}\not\equiv 0\ ({\rm mod}\ p)$ 时才有可能系数不为 $0$。 由 ${\rm Lucas}$ 定理可得 $\binom{a}{i}\equiv\binom{a\,\%\,p}{i\,\%\,p}·\binom{a\,/\,p}{i\,/\,p}$，即以 $p$ 进制分解组合数。 所以 $\binom{a}{i}\not\equiv 0\ ({\rm mod}\ p)$ 等价于 $p$ 进制下 $a$ 的每一位都不小于 $i$ 的同一位。 若 $a=\overline{a_ka_{k-1}\cdots a_0}_{(p)}$，则贡献为 $\prod\limits_{i=0}^k(a_i+1)$。 最后考虑 $\prod\limits_{i=1}^b(x+i)$。 若 $b\lt p-1$，由于 $(x^{p-1}-1)^a$ 中非 $0$ 项的次数一定为 $p-1$ 的倍数，而 $\prod\limits_{i=1}^b(x+i)$ 中非 $0$ 项的次数小于 $p-1$，一定不会出现重叠项。 那么原多项式中非 $0$ 项个数即为 $(x^{p-1}-1)^a$ 与 $\prod\limits_{i=1}^b(x+i)$ 非 $0$ 项个数之积。 后者直接分治 ${\rm FFT}$ 求解即可。 若 $b =p-1$，则 $\prod\limits_{i=1}^b(x+i)\equiv x^{p-1}-1\ ({\rm mod}\ p)$，证明同上。 计算 $(x^{p-1}-1)^a$ 时将 $a$ 加一即可。 使用 long double 版 ${\rm FFT}$ 即可通过，T老师的高精除法转 $p$ 进制代码精妙。 总时间复杂度为 $O(p\log^2p)$。 § 3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const long double PI = acos(-1.0L);const int MOD = 998244353;struct cpl&#123; long double r, i; inline cpl operator + (const cpl &amp;rhs) const &#123;return (cpl)&#123;r + rhs.r, i + rhs.i&#125;;&#125; inline cpl operator - (const cpl &amp;rhs) const &#123;return (cpl)&#123;r - rhs.r, i - rhs.i&#125;;&#125; inline cpl operator * (const cpl &amp;rhs) const &#123;return (cpl)&#123;r * rhs.r - i * rhs.i, r * rhs.i + i * rhs.r&#125;;&#125;&#125; W[262150];char n[1005];int p, len, a[3333], cnt = 0, ans = 1, rev[262150];inline void carryBit()&#123; for(register int i = 1; i &lt;= cnt + 5; i++) a[i + 1] += a[i] / p, a[i] %= p; for(cnt += 5; !a[cnt]; cnt--);&#125;inline void FFT(vector&lt;cpl&gt; &amp;a, int lim, int f)&#123; a.resize(lim); for(register int i = 1; i &lt; lim; i++) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(register int i = 1; i &lt; lim; i &lt;&lt;= 1)&#123; W[0] = (cpl)&#123;1, 0&#125;, W[1] = (cpl)&#123;cos(PI / i), f * sin(PI / i)&#125;; for(register int j = 2; j &lt; i; j++) W[j] = W[j - 1] * W[1]; for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = j; k &lt; j + i; k++)&#123; const cpl t = W[k - j] * a[k + i]; a[k + i] = a[k] - t, a[k] = a[k] + t; &#125; &#125; if(f == -1) for(register int i = 0; i &lt; lim; i++) a[i].r /= lim, a[i].i = 0;&#125;inline vector&lt;cpl&gt; mul(vector&lt;cpl&gt; f, vector&lt;cpl&gt; g)&#123; register int siz = f.size() + g.size() - 1, lim = 1, s = 0; while(lim &lt; siz) lim &lt;&lt;= 1, s++; for(register int i = 1; i &lt; lim; i++) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (s - 1); FFT(f, lim, 1), FFT(g, lim, 1); for(register int i = 0; i &lt; lim; i++) f[i] = f[i] * g[i]; FFT(f, lim, -1), f.resize(siz); for(auto &amp;i: f) i.r = (long long)(i.r + 0.5) % p; return f;&#125;vector&lt;cpl&gt; solve(int l, int r)&#123; if(l == r)&#123; static vector&lt;cpl&gt; p(2); return p[0] = (cpl)&#123;(long double)l, 0&#125;, p[1] = (cpl)&#123;1, 0&#125;, p; &#125; const int mid = l + r &gt;&gt; 1; return mul(solve(l, mid), solve(mid + 1, r));&#125;int main()&#123; scanf("%s%d", n, &amp;p), len = strlen(n); for(register int i = 0; i &lt; len; i++)&#123; for(register int j = 1; j &lt;= cnt; j++) a[j] *= 10; a[1] += n[i] &amp; 15, carryBit(); &#125; // High-precise division (n / p) if(a[1] == p - 1) a[2]++, a[1] = 0, carryBit(); for(register int i = 2; i &lt;= cnt; i++) ans = ans * (a[i] + 1LL) % MOD; if(a[1])&#123; auto res = solve(1, a[1]); int cnt = 0; for(auto i: res) cnt += ((int)(i.r + 0.5) != 0); ans = ans * (long long)cnt % MOD; &#125; return printf("%d\n", ans), 0;&#125;]]></content>
      <tags>
        <tag>生成函数</tag>
        <tag>分治FFT</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1217NOI模拟赛]set(组合数学)]]></title>
    <url>%2F2018%2F12%2F18%2FEZOI-1217NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-set-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[§ 1 题意记 $[n]=\lbrace 1,2,3,\cdots,n \rbrace$，对于集合 $S$ 定义 $\min S=\min\limits_{x\in S}x,\ \ F(S)=T^{\min S}$。 给出 $n,\ m,\ T$，求 $E(F(S)\ |\ S\subseteq [n],\ |S|=k)$ 的值，答案对 $M=998244353$ 取模。 $1\leq k\leq n\lt M,\ \ 1\leq k\leq 10^7,\ \ 1\leq T\lt M$。 § 2 分析令 $A_k=\sum\limits_{S\subseteq [n],\ |S|=k}F(S)$，则所求的答案等于 $\frac{A_k}{\binom{n}{k}}$。 考虑从组合意义入手求解 $A_k$，我们从 $1\sim n$ 枚举 $\min S$ 的最小值。 若当前最小值为 $i$，则可从比 $i$ 大的 $n-i$ 个数中取剩余 $k-1$ 个，贡献为 $T^i·\binom{n-i}{k-1}$，故有 \begin{align} A_k=\sum\limits_{i=1}^nT^i·\binom{n-i}{k-1} \end{align}等式两边同乘 $T$ ，可得 \begin{align} TA_k&=\sum\limits_{i=1}^nT^{i+1}·\binom{n-i}{k-1} \\ &=\sum\limits_{i=2}^{n+1}T^i·\binom{n-i+1}{k-1} \end{align}两式相减，可得 \begin{align} (T-1)\,A_k&=\sum\limits_{i=2}^nT^i·\left[\binom{n-i+1}{k-1}-\binom{n-i}{k-1}\right]-T·\binom{n-1}{k-1} \\ &=\sum\limits_{i=2}^nT^i·\binom{n-i}{k-2}-T·\binom{n-1}{k-1} \\ &=\sum\limits_{i=1}^nT^i·\binom{n-i}{k-2}-T·\left[\binom{n-1}{k-2}+\binom{n-1}{k-1}\right] \\ &=A_{k-1}-T·\binom{n}{k-1} \end{align}考虑只需要先求出 $T-1$ 的逆元以及 $i=0\sim k-1$ 的 $\binom{n}{i}$ 即可 $O(n)$ 递推出 $A_k$。 其中后者只需要先 $O(n)$ 递推出 $0\sim k-1$ 的逆元，然后即可从 $\binom{n}{0}$ 开始递推得到。 注意 $T=1$ 的情况一定不要忘记特判！这种情况下上式左边会变成 $0·A_k$ 而无法计算，直接输出 $1$ 即可。 总时间复杂度为 $O(n)$。 § 3 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int M = 998244353;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, k, T, inv[10000002], Cn[10000002], A[10000002], Inv;inline ll fastpow(ll bas, ll ex)&#123; register ll res = 1; bas %= M; while(ex)&#123; if(ex &amp; 1) res = res * bas % M; bas = bas * bas % M, ex &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; getint(n), getint(k), getint(T); if(T == 1) return puts("1"), 0; inv[1] = 1, Cn[0] = 1, Inv = fastpow(T - 1, M - 2), A[1] = T * (fastpow(T, n) - 1LL + M) % M * Inv % M; for(register int i = 2; i &lt;= k; i++) inv[i] = (M - M / i) * (ll)inv[M % i] % M; for(register int i = 1; i &lt;= k; i++) Cn[i] = Cn[i - 1] * (n - i + 1LL) % M * (ll)inv[i] % M; for(register int i = 2; i &lt;= k; i++) A[i] = ((A[i - 1] - T * (ll)Cn[i - 1]) % M + M) * Inv % M; return printf("%d", A[k] * fastpow(Cn[k], M - 2) % M), 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1215NOI模拟赛]树(树形DP+贪心+枚举)]]></title>
    <url>%2F2018%2F12%2F17%2FEZOI-1215NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%A0%91-%E6%A0%91%E5%BD%A2DP-%E8%B4%AA%E5%BF%83-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[§ 1 题意给出三棵节点分别为 $n1,\ n2,\ n3$ 的树，再连两条边可构成一棵新树。 求可能形成的新树中，所有点对距离和的最大值。 $n1,\ n2,\ n3\leq 100000$。 § 2 分析对于其中一棵大小为 $n$ 的树，令 $dis_i$ 表示点 $i$ 到其他所有点的距离和，考虑如何快速求解 $dis_i$。 钦定点 $1$ 为根，不难发现 $dis_1=\sum\limits_{i\in V,\ i\neq 1}siz_i$，且有 $dis_i=dis_{fa_i}+n-2\,siz_i$。 所以可以先自底向上树形 DP 求出 $siz_i$，再自顶向下树形 DP 求出 $dis_i$。 考虑连一条边合并两棵树，要使所有点对距离和最大，一定贪心连接两棵树各自 $dis_i$ 最大的点。 所以尝试三种可能的合并方法，重新计算新生成的三棵树的 $dis_i$，与剩下的树合并取最大答案即可。 总时间复杂度为 $O(n1+n2+n3)$。 § 3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n1, n2, n3;struct Edge &#123;int np; Edge *nxt;&#125;;struct Tree&#123; int n, tope, siz[200005], mx; ll dis[200005]; Edge E[400005], *V[200005]; inline void addedge(const int &amp;u, const int &amp;v) &#123;E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;&#125; void dfs1(int u, int fa)&#123; siz[u] = 1; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa) dfs1(ne-&gt;np, u), siz[u] += siz[ne-&gt;np]; if(u != 1) dis[1] += siz[u]; &#125; void dfs2(int u, int fa)&#123; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa) dis[ne-&gt;np] = dis[u] + n - 2 * siz[ne-&gt;np], dfs2(ne-&gt;np, u); &#125; inline void getmax()&#123; mx = 1; for(register int i = 2; i &lt;= n; i++) if(dis[i] &gt; dis[mx]) mx = i; &#125;&#125; T[6];int main()&#123; getint(n1), getint(n2), getint(n3), T[0].n = n1, T[1].n = n2, T[2].n = n3; T[3].n = n1 + n2, T[4].n = n1 + n3, T[5].n = n2 + n3; for(register int i = 1; i &lt; n1; i++)&#123; register int u, v; getint(u), getint(v); T[0].addedge(u, v), T[0].addedge(v, u); T[3].addedge(u, v), T[3].addedge(v, u); T[4].addedge(u, v), T[4].addedge(v, u); &#125; for(register int i = 1; i &lt; n2; i++)&#123; register int u, v; getint(u), getint(v); T[1].addedge(u, v), T[1].addedge(v, u); T[3].addedge(u + n1, v + n1), T[3].addedge(v + n1, u + n1); T[5].addedge(u, v), T[5].addedge(v, u); &#125; for(register int i = 1; i &lt; n3; i++)&#123; register int u, v; getint(u), getint(v); T[2].addedge(u, v), T[2].addedge(v, u); T[4].addedge(u + n1, v + n1), T[4].addedge(v + n1, u + n1); T[5].addedge(u + n2, v + n2), T[5].addedge(v + n2, u + n2); &#125; for(register int i = 0; i &lt;= 2; i++) T[i].dfs1(1, 0), T[i].dfs2(1, 0), T[i].getmax(); T[3].addedge(T[0].mx, T[1].mx + n1), T[3].addedge(T[1].mx + n1, T[0].mx); T[4].addedge(T[0].mx, T[2].mx + n1), T[4].addedge(T[2].mx + n1, T[0].mx); T[5].addedge(T[1].mx, T[2].mx + n2), T[5].addedge(T[2].mx + n2, T[1].mx); for(register int i = 3; i &lt;= 5; i++) T[i].dfs1(1, 0), T[i].dfs2(1, 0), T[i].getmax(); ll ans = 0; for(register int i = 3, j = 2; i &lt;= 5; i++, j--)&#123; register ll cur = 0; for(register int k = 1; k &lt;= T[i].n; k++) cur += T[i].dis[k]; for(register int k = 1; k &lt;= T[j].n; k++) cur += T[j].dis[k]; (cur &gt;&gt;= 1) += T[i].n * (ll)T[j].dis[T[j].mx] + T[i].dis[T[i].mx] * (ll)T[j].n + T[i].n * (ll)T[j].n; ans = max(ans, cur); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>树形DP</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1214NOI模拟赛]graph(搜索+数学)]]></title>
    <url>%2F2018%2F12%2F17%2FEZOI-1214NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-graph-%E6%90%9C%E7%B4%A2-%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定一个点数为 $n$，边数为 $m$ 的无向图 $G=\lt V,E\gt$。 边 $(i,j)$ 有边权 $w_{i,j}$，点 $i$ 有点权 $p_i$，且对于 $\forall\ (i,j)\in E,\ \ p_i+p_j\geq w_{i,j}$。 现要将顶点 $i$ 的权值减去 $c_i\ (0\leq c_i\leq p_i)$，记修改后点权 $p’_i=p_i-c_i$，对于 $\forall\ (i,j)\in E,\ \ p’_i+p’_j=w_{i,j}$。 求满足条件的 $\sum\limits_{i\in V}c_i$ 的最小值和最大值，如果不存在则输出 ${\rm NIE}$。 保证给出的图中无重边无自环。 $n\leq 500000,\ m\leq 3000000,\ 0\leq p_i\leq 10^6,\ 0\leq w_{i,j}\leq 10^6$。 § 2 分析首先令 $w’_{i,j}=p_i+p_j-w_{i,j}$，表示每条边两端点减小的值之和。 考虑一个连通块，若一个点的 $c_i$ 确定，则所有点的 $c_i$ 都能确定。 不妨钦定一个根节点 $s$，令 $c_s=x$，则可 ${\rm bfs}$ 出每个点 $i$ 的 $d_i$ 和 ${\rm sgn}_i\ ({\rm sgn}_i=\pm 1)$ 值使得 $c_i=d_i+{\rm sgn}_i·x$。 若在 ${\rm bfs}$ 过程中若多次访问到同一个点，则需要判断是否矛盾： 设访问边 $(i,j)$ 时两端值均已求出，则有 $c_i=d_i+{\rm sgn}_i·x,\ \ c_j=d_j+{\rm sgn}_j·x,\ \ w’_{i,j}=c_i+c_j$。 若 ${\rm sgn}_i=-{\rm sgn}_j$，则 $w’_{i,j}=d_i+d_j$，若不符合该等式则矛盾，直接输出 ${\rm NIE}$。 若 ${\rm sgn}_i={\rm sgn}_j$，则 $w’_{i,j}=d_i+d_j+2\,{\rm sgn}_i·x$，可以用该方程解出 $x=\frac{w’_{i,j}-d_i-d_j}{2\,{\rm sgn}_i}$，若 $x$ 不为整数或多个类似情况中解出的 $x$ 不同则矛盾，直接输出 ${\rm NIE}$。 对一个连通块 ${\rm bfs}$ 完后，考虑每个点本身的限制： 对于 $\forall\ i\in V,\ \ 0\leq d_i+{\rm sgn}_i·x\leq p_i$， 若 ${\rm sgn}_i = 1$，则化简得 $-d_i\leq x\leq p_i-d_i$。 若 ${\rm sgn}_i = -1$，则化简得 $d_i-p_i\leq x\leq d_i$。 对所有限制取交集得到形如 $\min x\leq x\leq\max x$ 的区间。 若此时 $\min x&gt;\max x$ 则区间为空，输出 ${\rm NIE}$。 若之前有解出过 $x$ 的精确值，则判断 $x$ 是否在区间内，若不在区间内则矛盾，输出 ${\rm NIE}$。 最后答案为 $\sum\limits_{i\in V}c_i=\sum\limits_{i\in V}d_i+x\sum\limits_{i\in V}{\rm sgn}_i$，是一个常数或一次函数，易于统计最大值和最小值。 总时间复杂度为 $O(n+m)$。 注意 &amp;&amp; 是短路运算符，原来第 $42\sim44$ 行写了 123if(x &amp; 1) koware();if(~defx &amp;&amp; (x &gt;&gt;= 1) != defx) koware();defx = x; 结果 ${\rm WA}$ 成 $65$ 分 $(っ °Д °;)っ$，改成如下就 ${\rm AC}$ 了123if(x &amp; 1) koware(); else x &gt;&gt;= 1;if(~defx &amp;&amp; x != defx) koware();defx = x; § 3 代码注：c[i] 表示本文中的 ${\rm sgn}_i$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MAXV = 500005, MAXE = 6000005;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;template &lt;typename T&gt; inline void checkmax(T &amp;a, const T &amp;b) &#123;if(a &lt; b) a = b;&#125;template &lt;typename T&gt; inline void checkmin(T &amp;a, const T &amp;b) &#123;if(b &lt; a) a = b;&#125;int n, m, p[MAXV], q[MAXV], c[MAXV];ll d[MAXV], minans, maxans; bool vis[MAXV];struct Edge &#123;int np, val; Edge *nxt;&#125; E[MAXE], *V[MAXV];inline void addedge(const int &amp;u, const int &amp;v, const int &amp;w)&#123; static int tope = 0; E[++tope].np = v, E[tope].val = w, E[tope].nxt = V[u], V[u] = E + tope;&#125;inline void koware() &#123;puts("NIE"), exit(0);&#125;inline void bfs(const int &amp;s)&#123; register int l = 0, r = 1, defx = -1; q[0] = s, c[s] = 1; while(l &lt; r)&#123; const int &amp;u = q[l++]; vis[u] = 1; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt)&#123; if(!c[ne-&gt;np]) c[ne-&gt;np] = -c[u], d[ne-&gt;np] = ne-&gt;val - d[u], q[r++] = ne-&gt;np; else if(!vis[ne-&gt;np])&#123; if(c[u] == c[ne-&gt;np])&#123; register ll x = (ne-&gt;val - d[u] - d[ne-&gt;np]) * c[u]; if(x &amp; 1) koware(); else x &gt;&gt;= 1; if(~defx &amp;&amp; x != defx) koware(); defx = x; &#125; else if(d[u] + d[ne-&gt;np] != ne-&gt;val) koware(); &#125; &#125; &#125; register ll minx = 0, maxx = p[s], sumc = 1, sumd = 0; for(register int i = 1; i &lt; r; i++)&#123; const int &amp;u = q[i]; if(c[u] == 1) checkmax(minx, -d[u]), checkmin(maxx, p[u] - d[u]); else checkmax(minx, d[u] - p[u]), checkmin(maxx, d[u]); sumc += c[u], sumd += d[u]; &#125; if(minx &gt; maxx) koware(); if(~defx)&#123; if(defx &lt; minx || defx &gt; maxx) koware(); minans += sumc * defx + sumd, maxans += sumc * defx + sumd; &#125; else&#123; if(sumc &gt;= 0) minans += sumc * minx + sumd, maxans += sumc * maxx + sumd; else minans += sumc * maxx + sumd, maxans += sumc * minx + sumd; &#125;&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(p[i]); for(register int i = 1; i &lt;= m; i++)&#123; int u, v, w; getint(u), getint(v), getint(w); addedge(u, v, p[u] + p[v] - w), addedge(v, u, p[u] + p[v] - w); &#125; for(register int i = 1; i &lt;= n; i++) if(!vis[i]) bfs(i); return printf("%lld %lld\n", minans, maxans), 0;&#125;]]></content>
      <tags>
        <tag>搜索</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1211NOI模拟赛]Lis(线段树+set)]]></title>
    <url>%2F2018%2F12%2F13%2FEZOI-1211NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-Lis-%E7%BA%BF%E6%AE%B5%E6%A0%91-set%2F</url>
    <content type="text"><![CDATA[§ 1 题意街道上有 $n$ 个位置可用来种树，自西向东标号为 $1 \sim n$。 共 $m$ 个月，在第 $i$ 个月的开始，有以下操作之一： 在编号为 $p_i$ 的位置种植一棵高度为 $h_i$ 米的树，保证每个位置只会出现一次。 砍倒自西向东数第 $x_i$ 棵树，保证存在。 其中栽下的树木每月长高 $1$ 米，且保证任意时刻没有两棵树的高度相同。 求每次操作后输出树高序列的最长上升子序列长度。 $n \leq 10^5,m \leq 10^5, p_i \leq n,1 \leq h_i \leq 10,x_i \leq 10$。 § 2 分析首先考虑操作 $1$，由于 $1 \leq h_i \leq 10$ 且树木每月长高 $1$ 米，故 $10$ 个月及以前种植的树一定高于当前树。 令 ${\rm LIS}_i$ 表示以位置 $i$ 的树开头的最长上升子序列长度。 考虑用队列存最后种植的 $10$ 棵树，然后以位置为下标建立线段树维护其余的 ${\rm LIS}_i$ 最大值。 在位置 $p$ 种植高度为 $h$ 的树时，先将队列中最早种植的树的 ${\rm LIS}_i$ 插入“位置线段树”，并在队列中删除；然后用“位置线段树”中的后缀 $\max$ 更新当前树，并加入队列；最后 $O(10^2)$ 暴力更新队列中的树的 ${\rm LIS}_i$ 即可。 然后考虑操作 $2$，发现删除自西向东第 $x_i$ 棵树只会影响第 $1 \sim x_i-1$ 棵树的 ${\rm LIS}_i$。 题目保证任意时刻没有高度相同的树，考虑以高度为下标建立线段树维护全局 ${\rm LIS}_i$ 最大值。 由于 $1 \leq x_i \leq 10$，我们可以在种树时直接把位置存到一个 set 里，那么删除时只需先把前 $x_i$ 棵全取出，并在“高度线段树”中先将其去除；然后把要删除的第 $x_i$ 棵在 set 和“位置线段树”中去除；最后倒序遍历前 $x_i-1$ 棵树，用“高度线段树”中的后缀 $\max$ 更新后，重新插入“高度线段树”（倒序可以保证一棵树不被前面的树更新）。 最后一定要注意细节，总时间复杂度为 $O(m\log m+10\,m\log n)​$。 § 3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;inline void checkmax(int &amp;a, const int &amp;b) &#123;if(a &lt; b) a = b;&#125;int n, m, h[100005];int q[100005], inq[100005], fr, re, lis[100005], del[100005];int tmp[100005], cnt;set&lt;int&gt; s; set&lt;int&gt;::iterator it;struct Segtree&#123; int mx[400050]; #define lch (u &lt;&lt; 1) #define rch (u &lt;&lt; 1 | 1) inline void modify(int u, int l, int r, int p, int v)&#123; while(l &lt; r)&#123; const int mid = l + r &gt;&gt; 1; if(p &lt;= mid) u = lch, r = mid; else u = rch, l = mid + 1; &#125; mx[u] = v; while(u &gt;&gt;= 1) mx[u] = max(mx[lch], mx[rch]); &#125; int query(int u, int l, int r, int ql, int qr)&#123; if(ql &gt; qr) return 0; if(l == ql &amp;&amp; r == qr) return mx[u]; const int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(lch, l, mid, ql, qr); if(ql &gt; mid) return query(rch, mid + 1, r, ql, qr); return max(query(lch, l, mid, ql, mid), query(rch, mid + 1, r, mid + 1, qr)); &#125;&#125; P, H;int main()&#123; getint(n), getint(m); for(register int gatsu = 1; gatsu &lt;= m; gatsu++)&#123; int opt, p; getint(opt), getint(p); if(opt == 1)&#123; getint(h[p]), h[p] += m - gatsu; s.insert(p), q[re++] = p, inq[p] = 1, del[p] = 0; if(re - fr &gt; 10)&#123; if(!del[q[fr]]) P.modify(1, 1, n, q[fr], lis[q[fr]]); inq[q[fr++]] = 0; &#125; lis[p] = P.query(1, 1, n, p + 1, n) + 1, cnt = 0; for(register int i = fr; i != re; i++) if(!del[q[i]]) tmp[++cnt] = q[i]; sort(tmp + 1, tmp + cnt + 1); for(register int i = cnt; i; i--)&#123; for(register int j = i + 1; j &lt;= cnt; j++) if(h[tmp[i]] &lt; h[tmp[j]]) checkmax(lis[tmp[i]], lis[tmp[j]] + 1); H.modify(1, 1, m + 10, h[tmp[i]], lis[tmp[i]]); &#125; &#125; else&#123; tmp[cnt = 1] = *(it = s.begin()), H.modify(1, 1, m + 10, h[*it], 0); for(register int i = 2; i &lt;= p; i++) tmp[++cnt] = *++it, H.modify(1, 1, m + 10, h[*it], 0); P.modify(1, 1, n, *it, 0), del[*it] = 1, s.erase(it); while(--cnt)&#123; lis[tmp[cnt]] = H.query(1, 1, m + 10, h[tmp[cnt]] + 1, m + 10) + 1; H.modify(1, 1, m + 10, h[tmp[cnt]], lis[tmp[cnt]]); if(!inq[tmp[cnt]]) P.modify(1, 1, n, tmp[cnt], lis[tmp[cnt]]); &#125; &#125; printf("%d\n", H.mx[1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1211NOI模拟赛]LCM(根号分治+容斥)]]></title>
    <url>%2F2018%2F12%2F12%2FEZOI-1211NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-LCM-%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB-%E5%AE%B9%E6%96%A5%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定一个大小为 $n$ 的数集 $S$，求 $\sum\limits_{S’ \subseteq S,S’ \neq \emptyset} {\rm LCM}(S’)$，即 $S$ 所有非空子集的 ${\rm LCM}$ 和。 $n \leq 2000,a_i \leq 200$。 § 2 分析首先发现 $a_i \leq 200$ 很小，考虑是否可以分解质因数统计。但 $200$ 以内的质数有 $46$ 个，组成的 ${\rm LCM}$ 值域过大。 考虑根号分治，观察发现 $\gt \sqrt{a_i} \approx 14$ 的质数的幂次最高为 $1$，而 $\leq 14$ 的质数只有 $6$ 个，分别为 $2,3,5,7,11,13$，其最高幂次分别为 $7,4,3,2,2,2$。 所以若只考虑 $2,3,5,7,11,13$，则 ${\rm LCM}$ 的不同值至多只有 $8\times5\times4\times3\times3\times3=4320$ 种。 我们将 $a_i$ 按除完 $2,3,5,7,11,13$ 后剩下的值 $c_i$ 分类，可以证明 $c_i=1 $ 或 $\gt 13$ 的质数。 令 $f_{c,p_1,p_2,p_3,p_4,p_5,p_6}$ 表示除完后剩下的值为 $c$ 时，是 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 因数的数的个数： 12345678for(register int i = 1; i &lt;= n; i++) for(register int p1 = a[i][1]; p1 &lt;= mx[1]; p1++) for(register int p2 = a[i][2]; p2 &lt;= mx[2]; p2++) for(register int p3 = a[i][3]; p3 &lt;= mx[3]; p3++) for(register int p4 = a[i][4]; p4 &lt;= mx[4]; p4++) for(register int p5 = a[i][5]; p5 &lt;= mx[5]; p5++) for(register int p6 = a[i][6]; p6 &lt;= mx[6]; p6++) f[c[i]][p1][p2][p3][p4][p5][p6]++; 令 $g_{p1,p2,p3,p4,p5,p6}$ 表示不考虑 $\gt 13$ 的因子时 ${\rm LCM}$ 为 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 的因数的子集数。 首先考虑除完后剩下的值 $c=1$ 时，$F=f_{1,p_1,p_2,p_3,p_4,p_5,p_6}$ 个数中的每个要么选要么不选，共有 $2^F$ 种可能： 1234567for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) g[p1][p2][p3][p4][p5][p6] = bin[f[1][p1][p2][p3][p4][p5][p6]]; 然后考虑除完后剩下的值 $c\gt 13$ 时，$F=f_{c,p_1,p_2,p_3,p_4,p_5,p_6}$ 个数中，都不选有 $1$ 种可能，选至少一个都会导致 ${\rm LCM}$ 扩大 $c$ 倍，由于只需统计 ${\rm LCM}$ 的和，可将一种算作 $c$ 种，等价于共有 $1+c\times(2^F-1)$ 种可能： 12345678910for(register int i = 1; i &lt;= 40; i++)&#123; const int &amp;r = rem[i]; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) (g[p1][p2][p3][p4][p5][p6] *= (r * (bin[f[r][p1][p2][p3][p4][p5][p6]] - 1LL + MOD) + 1LL) % MOD) %= MOD;&#125; 接下来通过容斥原理即可将 $g_{p1,p2,p3,p4,p5,p6}$ 转化为不考虑 $\gt 13$ 的因子时 ${\rm LCM}$ 严格等于 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 的子集数，注意容斥要从大到小进行： 12345678910111213141516for(register int p1 = mx[1]; ~p1; p1--) for(register int p2 = mx[2]; ~p2; p2--) for(register int p3 = mx[3]; ~p3; p3--) for(register int p4 = mx[4]; ~p4; p4--) for(register int p5 = mx[5]; ~p5; p5--) for(register int p6 = mx[6]; ~p6; p6--) for(register int d1 = 0; d1 &lt;= 1 &amp;&amp; d1 &lt;= p1; d1++) for(register int d2 = 0; d2 &lt;= 1 &amp;&amp; d2 &lt;= p2; d2++) for(register int d3 = 0; d3 &lt;= 1 &amp;&amp; d3 &lt;= p3; d3++) for(register int d4 = 0; d4 &lt;= 1 &amp;&amp; d4 &lt;= p4; d4++) for(register int d5 = 0; d5 &lt;= 1 &amp;&amp; d5 &lt;= p5; d5++) for(register int d6 = 0; d6 &lt;= 1 &amp;&amp; d6 &lt;= p6; d6++) if(d1 | d2 | d3 | d4 | d5 | d6)&#123; if(d1 ^ d2 ^ d3 ^ d4 ^ d5 ^ d6) (g[p1][p2][p3][p4][p5][p6] += MOD - g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; else (g[p1][p2][p3][p4][p5][p6] += g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; &#125; 最后答案即为 $\sum\limits_{p1,p2,p3,p4,p5,p6}2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}\times g_{p1,p2,p3,p4,p5,p6}$ 减去 $1$，即除去空集。 总时间复杂度为 $O(8\times5\times4\times3\times3\times3\times(n+40+2^6))​$。 § 3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MOD 1000000007using namespace std;typedef long long ll;const int prm[7] = &#123;1, 2, 3, 5, 7, 11, 13&#125;;const int rem[41] = &#123;1, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199&#125;;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, mx[7], a[2005][7], c[2005], v[8][5][4][3][3][3], f[205][8][5][4][3][3][3], bin[2005], ans;ll g[8][5][4][3][3][3];int main()&#123; getint(n), bin[0] = 1; for(register int i = 1; i &lt;= n; i++) bin[i] = (bin[i - 1] &lt;&lt; 1) % MOD; for(register int i = 1; i &lt;= n; i++)&#123; int v; getint(v); for(register int j = 1; j &lt;= 6; j++) while(v % prm[j] == 0)&#123; if(++a[i][j] &gt; mx[j]) mx[j] = a[i][j]; v /= prm[j]; &#125; c[i] = v; &#125; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++)&#123; if(p1) v[p1][p2][p3][p4][p5][p6] = v[p1 - 1][p2][p3][p4][p5][p6] * 2 % MOD; else if(p2) v[p1][p2][p3][p4][p5][p6] = v[p1][p2 - 1][p3][p4][p5][p6] * 3 % MOD; else if(p3) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3 - 1][p4][p5][p6] * 5 % MOD; else if(p4) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4 - 1][p5][p6] * 7 % MOD; else if(p5) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4][p5 - 1][p6] * 11 % MOD; else if(p6) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4][p5][p6 - 1] * 13 % MOD; else v[p1][p2][p3][p4][p5][p6] = 1; &#125; // 预处理 2^p1 * 3^p2 * 5^p3 * 7^p4 * 11^p5 * 13^p6 的值 for(register int i = 1; i &lt;= n; i++) for(register int p1 = a[i][1]; p1 &lt;= mx[1]; p1++) for(register int p2 = a[i][2]; p2 &lt;= mx[2]; p2++) for(register int p3 = a[i][3]; p3 &lt;= mx[3]; p3++) for(register int p4 = a[i][4]; p4 &lt;= mx[4]; p4++) for(register int p5 = a[i][5]; p5 &lt;= mx[5]; p5++) for(register int p6 = a[i][6]; p6 &lt;= mx[6]; p6++) f[c[i]][p1][p2][p3][p4][p5][p6]++; // 按 c[i] 分组统计可能对 LCM = 2^p1 * 3^p2 * 5^p3 * 7^p4 * 11^p5 * 13^p6 有贡献的数的个数 for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) g[p1][p2][p3][p4][p5][p6] = bin[f[1][p1][p2][p3][p4][p5][p6]]; // c[i] = 1 的对答案贡献倍数为 2^f for(register int i = 1; i &lt;= 40; i++)&#123; const int &amp;r = rem[i]; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) (g[p1][p2][p3][p4][p5][p6] *= (r * (bin[f[r][p1][p2][p3][p4][p5][p6]] - 1LL + MOD) + 1LL) % MOD) %= MOD; &#125; // c[i] &gt; 13 的对答案贡献倍数为 1 + (c[i] * 2^f - 1) for(register int p1 = mx[1]; ~p1; p1--) for(register int p2 = mx[2]; ~p2; p2--) for(register int p3 = mx[3]; ~p3; p3--) for(register int p4 = mx[4]; ~p4; p4--) for(register int p5 = mx[5]; ~p5; p5--) for(register int p6 = mx[6]; ~p6; p6--) for(register int d1 = 0; d1 &lt;= 1 &amp;&amp; d1 &lt;= p1; d1++) for(register int d2 = 0; d2 &lt;= 1 &amp;&amp; d2 &lt;= p2; d2++) for(register int d3 = 0; d3 &lt;= 1 &amp;&amp; d3 &lt;= p3; d3++) for(register int d4 = 0; d4 &lt;= 1 &amp;&amp; d4 &lt;= p4; d4++) for(register int d5 = 0; d5 &lt;= 1 &amp;&amp; d5 &lt;= p5; d5++) for(register int d6 = 0; d6 &lt;= 1 &amp;&amp; d6 &lt;= p6; d6++) if(d1 | d2 | d3 | d4 | d5 | d6)&#123; if(d1 ^ d2 ^ d3 ^ d4 ^ d5 ^ d6) (g[p1][p2][p3][p4][p5][p6] += MOD - g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; else (g[p1][p2][p3][p4][p5][p6] += g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; &#125; // 通过容斥将"小于等于"转化为严格等于 for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) ans = (ans + g[p1][p2][p3][p4][p5][p6] * v[p1][p2][p3][p4][p5][p6]) % MOD; printf("%d\n", (ans + MOD - 1) % MOD); return 0;&#125;]]></content>
      <tags>
        <tag>根号分治</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1211NOI模拟赛]Xor(线性基)]]></title>
    <url>%2F2018%2F12%2F12%2FEZOI-1211NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-Xor-%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定简单无向连通带权图 $G=\lt V,E\gt$，其中对于 $u \in V$ 有点权 $W_u$，对于 $(i,j) \in E$ 有边权 $w_{i,j}$。 定义边集 $E$ 的权值为 $\bigoplus\limits_{(i,j) \in E} w_{i,j}$。 若一个割 $C$ 将图 $G$ 的点集 $V$ 分成 $S,T$ 两部分，其中 $S \cup T=V$，则简记为 $C=\lt S,T\gt$。 定义一个割 $C$ 是合法的，当且仅当对于 $\forall S’ \subseteq S,S’ \neq \emptyset$，割边集 $C’=\lt S’,T’\gt(T’=V-S’)$ 的权值均非 $0$。 求合法割集中 $\sum\limits_{u \in S}W_u-\sum\limits_{u \in T}W_u$ 的最大值。 $n \leq 10^5,m \leq 2*10^5,W_u \leq 10^{12},w_{i,j} \lt 2^{63}$。 § 2 分析边 $(i,j)$ 在割集 $C=\lt S,T\gt$ 中，当且仅当它的一个端点在 $S$ 中，另一个在 $T$ 中。此时割集权值要异或 $w_{i,j}$。 如果边 $(i,j)$ 的两个端点均在 $S$ 中，可以视作割集权值异或两次 $w_{i,j}$，等价于没有贡献。 记点 $u$ 所有出边的边权异或和 $f_u=\bigoplus\limits_{(u,i) \in E} w_{u,i}$，则割 $C=\lt S,T\gt$ 的权值为 $\bigoplus\limits_{u \in S}f_u$。 由于合法割集需要满足不存在 $S’ \subseteq S,S’ \neq \emptyset$ 使得割 $C’=\lt S’,V-S’\gt$ 权值为 $0$，所以 $S$ 中的点的 $f_u$ 要线性无关，使用线性基按 $W_u$ 从大到小贪心即可。 总时间复杂度为 $O(n\log w)$。 § 3 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;template &lt;typename T&gt; inline void getint(T &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, m; ll bas[63], tot = 0, ans = 0;struct Node &#123;ll w, f;&#125; p[100005];inline bool operator &lt; (const Node &amp;p1, const Node &amp;p2) &#123;return p1.w &gt; p2.w;&#125;inline int ins(ll val)&#123; for(register int i = 62; ~i; i--) if(val &amp; (1LL &lt;&lt; i)) if(bas[i]) val ^= bas[i]; else return bas[i] = val, 1; return 0;&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(p[i].w), tot += p[i].w; for(register int i = 1; i &lt;= m; i++)&#123; int u, v; ll w; getint(u), getint(v), getint(w); p[u].f ^= w, p[v].f ^= w; &#125; sort(p + 1, p + n + 1); for(register int i = 1; i &lt;= n; i++) if(ins(p[i].f)) ans += p[i].w; printf("%lld\n", ans * 2 - tot); return 0;&#125;]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1208NOI模拟赛]Forest(multiset)]]></title>
    <url>%2F2018%2F12%2F10%2FEZOI-1208NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-Forest-multiset%2F</url>
    <content type="text"><![CDATA[§ 1 题意有一个点数为 $n$ 的有向图，每个点出度均为 $1$。 给出每个点的后继 $A_i$ 和点权 $B_i$，保证 $A_i \neq i$ 且 $A_{A_i} \neq i$。 记点 $i$ 的总度数为 $D_i$，并定义 $E_i = \lfloor \frac{B_i}{D_i} \rfloor$，稠密度 $C_i=B_i-D_i*E_i+\sum_{j=1}^{D_i}E_{P_j}$。 请实现一个稠密度分析仪，支持以下三种操作： $1$ $i$ $j$ ：把 $i$ 点的后继改为 $j$，即令 $A_i=j$，保证 $j \neq i$ 且 $A_j \neq i$。 $2​$ $i​$ ：询问 $i​$ 点的稠密度 $C_i​$。 $3$ ：询问所有节点中，$C_i$ 的最小值和最大值。 $3 \leq n \leq 10^5$，$1 \leq q \leq 10^5$，$1 \leq B_i \leq 10^{12}$，$1 \leq A_i \leq n$。 题目来源：Codeforces 643D - Bearish Fanpages。 § 2 分析首先化简得 $C_i=B_i \% D_i+\sum_{j=1}^{D_i}E_{P_j}$。 考虑操作 $1$，将点 $i$ 的后继从 $A_i$ 改为 $j$，若 $A_i==j$ 则跳过，否则考虑改动所造成的影响： $A_i$ 的度数减少 $1$，即 $D_{A_i}$ 减去 $1$，导致 $E_{A_i} = \lfloor \frac{B_{A_i}}{D_{A_i}} \rfloor$ 改变。 $j$ 的度数增加 $1$，即 $D_j$ 加上 $1$，导致 $E_j = \lfloor \frac{B_j}{D_j} \rfloor$ 改变。 连边情况改变，即最后令 $A_i=j​$。 当某个 $E_i$ 改变时，$C_{i}$、$C_{A_i}$ 以及 $i$ 所有前驱 $j$ 的 $C_j$ 都要改变。 § 2.1 弱化版若没有 $3$ 操作，则我们考虑维护 $C’_i=C_i-E_{A_i}$，即不计后继贡献时的答案。 执行 $1$ $i$ $j$ 操作时，由于不计后继贡献， $C’_i$ 不会改变，重算 $E_{A_i}$ 和 $E_j$，更新 $C’_{A_i}$、$C’_{A_{A_i}}$、$C’_j$ 和 $C’_{A_j}$。 执行 $2$ $i$ 操作时，直接输出 $C’_i+E_{A_i}$ 即可。 总体可在 $O(n)$ 时间内解决。 § 2.2 维护极值考虑 $3$ 操作，我们可以对每个节点 $i$ 用 multiset 维护其前驱 $C’_i$ 的极值，然后取每个 multiset 中的极值再放入 multiset 中维护，即可在 $O(n\log n)$ 时间内解决本题。 注意每次更新 $C’_i$ 时，先在维护总体极值的 multiset 中删除，然后在父节点的 multiset 中删除，修改 $C’_i$ 后再在父节点的 multiset 中插入，最后在总体极值的 multiset 中插入即可。 § 3 代码注：C[i] 表示本文中的 $C’_i$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;typedef long long ll;template &lt;typename T&gt; inline void getint(T &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, q, A[100005], D[100005];ll B[100005], E[100005], C[100005];multiset&lt;ll&gt; s[100005], maxs, mins;inline void ins(const int &amp;u)&#123; if(s[u].empty()) return; maxs.insert(*s[u].rbegin() + E[u]); mins.insert(*s[u].begin() + E[u]);&#125;inline void del(const int &amp;u)&#123; if(s[u].empty()) return; maxs.erase(maxs.find(*s[u].rbegin() + E[u])); mins.erase(mins.find(*s[u].begin() + E[u]));&#125;int main()&#123; getint(n), getint(q); for(register int i = 1; i &lt;= n; i++) getint(B[i]), D[i] = 2; for(register int i = 1; i &lt;= n; i++) getint(A[i]), D[A[i]]++; for(register int i = 1; i &lt;= n; i++) E[i] = B[i] / D[i], C[i] = B[i] % D[i] + E[i]; for(register int i = 1; i &lt;= n; i++) C[A[i]] += E[i]; for(register int i = 1; i &lt;= n; i++) s[A[i]].insert(C[i]); for(register int i = 1; i &lt;= n; i++) ins(i); while(q--)&#123; int opt, u, v; getint(opt); if(opt == 1)&#123; getint(u), getint(v); if(A[u] == v) continue; int p = A[u], q = A[p], r = A[q]; del(p), s[p].erase(s[p].find(C[u])); del(q), s[q].erase(s[q].find(C[p])); del(r), s[r].erase(s[r].find(C[q])); C[p] -= B[p] % D[p] + E[u] + E[p], C[q] -= E[p]; E[p] = B[p] / --D[p]; C[p] += B[p] % D[p] + E[p], C[q] += E[p]; ins(p); s[q].insert(C[p]), ins(q); s[r].insert(C[q]), ins(r); p = A[u] = v, q = A[p], r = A[q]; del(p); del(q), s[q].erase(s[q].find(C[p])); del(r), s[r].erase(s[r].find(C[q])); C[p] -= B[p] % D[p] + E[p], C[q] -= E[p]; E[p] = B[p] / ++D[p]; C[p] += B[p] % D[p] + E[u] + E[p], C[q] += E[p]; s[p].insert(C[u]), ins(p); s[q].insert(C[p]), ins(q); s[r].insert(C[q]), ins(r); &#125; else if(opt == 2) getint(u), printf("%lld\n", C[u] + E[A[u]]); else if(opt == 3) printf("%lld %lld\n", *mins.begin(), *maxs.rbegin()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈动态DP]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81DP%2F</url>
    <content type="text"><![CDATA[§ 1 前言本文大量参考 txc 巨爷的《基于变换合并的树上动态DP的链分治算法和全局平衡二叉树学习笔记》一文。在某些问题中，我们需要实现对某种 DP 的权值修改，以及快速询问全局或子结构的 DP 值。 如果我们能找到一种满足结合律的运算来描述转移过程的话，就可以用数据结构维护合并，降低复杂度。 § 2 例题一=&gt; luogu 4719 【模板】动态dp§ 2.1 题意给定一棵有 $i$ 个点的树，第 $i$ 个点的点权为 $a_i$。 有 $m$ 次操作，每次操作给定 $x,y$，表示将点 $x$ 的权值修改为 $y$。 求每次操作后这棵树的最大权独立集的权值，其中独立集指任意两个顶点不相邻的点集。 $n,m \leq 10^5$。 § 2.2 分析本题的模型为树上带修最大权独立集，是动态 DP 的模板题。 § 2.2.1 弱化版首先考虑如果没有修改操作，我们可以直接进行 $\Theta(n)$ 的树形 DP。 令 $f_{u,0/1}$ 表示以 $u$ 为根的子树中，不选 / 选 $u$ 时的最大权独立集的权值，则有 \begin{align} f_{u,0}&=\sum_{u→v}max\{f_{v,0},f_{v,1}\} \\ f_{u,1}&=a_u+\sum_{u→v}f_{v,0}\end{align}§ 2.2.2 重写转移考虑树链剖分，求出 $u$ 的重儿子 $hson_u​$。单独取出重儿子贡献的一项，则 DP 转化为 \begin{align} f_{u,0}&=max\{f_{hson_u,0},f_{hson_u,1}\}+\sum_{u→v,v\neq hson_u}max\{f_{v,0},f_{v,1}\} \\ f_{u,1}&=a_u+f_{hson_u,0}+\sum_{u→v,v\neq hson_u}f_{v,0}\end{align}记 \begin{align} g_{u,0}&=\sum_{u→v,v\neq hson_u}max\{f_{v,0},f_{v,1}\} \\ g_{u,1}&=a_u+\sum_{u→v,v\neq hson_u}f_{v,0}\end{align}则有 \begin{align} f_{u,0}&=max\{f_{hson_u,0},f_{hson_u,1}\}+g_{u,0} \\ f_{u,1}&=f_{hson_u,0}+g_{u,1}\end{align}§ 2.2.3 矩阵优化我们重新定义矩阵乘法 $C=A*B$ 来描述这个转移，令 $\begin{align} c_{i,j}=\max \limits_k(a_{i,k}+b_{k,j}) \end{align} $ 则转移可写为 \begin{equation} \left( \begin{array}{c} f_{u,0} \\ f_{u,1} \end{array} \right)= \left( \begin{array}{cc} g_{u,0} & g_{u,0} \\ g_{u,1} & -\infty \end{array} \right) \left( \begin{array}{c} f_{hson_u,0} \\ f_{hson_u,1} \end{array} \right) \end{equation}可以证明重定义的矩阵乘法是具有结合律的，且存在单位矩阵\begin{equation}\left( \begin{array}{cc} 0 & -\infty \\ -\infty & 0 \end{array} \right) \end{equation}。 求一个点的 DP 值时，只需将该点沿重链走到底的矩阵相乘即可。 由于重链在 dfs 序上连续，可以用线段树维护区间矩阵乘积。修改类似树链剖分，重复以下步骤： 更新当前点的矩阵； 跳到重链顶端，同时计算 DP 值，更新父节点的 $g$ 值，并跳到父节点。 这样单次修改复杂度为 $O(\log^2n)$，查询复杂度为 $O(\log n)$。 § 2.3 代码注：leafdfn[u] 表示点 $u​$ 所在重链底部节点的 dfs 序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, m, a[100005], f[100005][2], g[100005][2];int fa[100005], siz[100005], hson[100005];int dfn[100005], dfstime = 0, id[100005], top[100005], leafdfn[100005];struct Edge &#123;int np; Edge *nxt;&#125; E[200005], *V[100005];inline void addedge(const int &amp;u, const int &amp;v)&#123; static int tope = 0; E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;&#125;struct Matrix&#123; int v[2][2]; inline Matrix() &#123;v[0][0] = v[1][1] = 0, v[0][1] = v[1][0] = -inf;&#125; inline Matrix(int g0, int g1) &#123;v[0][0] = v[0][1] = g0, v[1][0] = g1, v[1][1] = -inf;&#125; inline Matrix operator * (const Matrix &amp;mat) const&#123; static Matrix res; res.v[0][0] = max(v[0][0] + mat.v[0][0], v[0][1] + mat.v[1][0]); res.v[0][1] = max(v[0][0] + mat.v[0][1], v[0][1] + mat.v[1][1]); res.v[1][0] = max(v[1][0] + mat.v[0][0], v[1][1] + mat.v[1][0]); res.v[1][1] = max(v[1][0] + mat.v[0][1], v[1][1] + mat.v[1][1]); return res; &#125;&#125; s[400005];void dfs1(int u)&#123; siz[u] = 1, hson[u] = 0, f[u][1] = a[u]; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u])&#123; fa[ne-&gt;np] = u, dfs1(ne-&gt;np), siz[u] += siz[ne-&gt;np]; if(siz[ne-&gt;np] &gt; siz[hson[u]]) hson[u] = ne-&gt;np; f[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), f[u][1] += f[ne-&gt;np][0]; &#125;&#125;void dfs2(int u)&#123; id[dfn[u] = ++dfstime] = u, g[u][1] = a[u]; if(hson[u]) top[hson[u]] = top[u], dfs2(hson[u]), leafdfn[u] = leafdfn[hson[u]]; else leafdfn[u] = dfstime; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u] &amp;&amp; ne-&gt;np != hson[u])&#123; top[ne-&gt;np] = ne-&gt;np, dfs2(ne-&gt;np); g[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), g[u][1] += f[ne-&gt;np][0]; &#125;&#125;#define lch (u &lt;&lt; 1)#define rch (u &lt;&lt; 1 | 1)void build(int u, int l, int r)&#123; if(l == r) &#123;s[u] = Matrix(g[id[l]][0], g[id[l]][1]); return;&#125; const int mid = l + r &gt;&gt; 1; build(lch, l, mid), build(rch, mid + 1, r); s[u] = s[lch] * s[rch];&#125;void modify(int u, int l, int r, int pos)&#123; if(l == r) &#123;s[u] = Matrix(g[id[l]][0], g[id[l]][1]); return;&#125; const int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) modify(lch, l, mid, pos); else modify(rch, mid + 1, r, pos); s[u] = s[lch] * s[rch];&#125;Matrix query(int u, int l, int r, int ql, int qr)&#123; if(l == ql &amp;&amp; r == qr) return s[u]; const int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(lch, l, mid, ql, qr); if(ql &gt; mid) return query(rch, mid + 1, r, ql, qr); return query(lch, l, mid, ql, mid) * query(rch, mid + 1, r, mid + 1, qr);&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(a[i]); for(register int i = 1; i &lt; n; i++)&#123; int u, v; getint(u), getint(v); addedge(u, v), addedge(v, u); &#125; dfs1(1), top[1] = 1, dfs2(1); build(1, 1, n); while(m--)&#123; int x, y; getint(x), getint(y); g[x][1] += y - a[x], a[x] = y; while(x)&#123; modify(1, 1, n, dfn[x]), x = top[x]; Matrix res = query(1, 1, n, dfn[x], leafdfn[x]); g[fa[x]][0] -= max(f[x][0], f[x][1]), g[fa[x]][1] -= f[x][0]; f[x][0] = res.v[0][0], f[x][1] = res.v[1][0]; g[fa[x]][0] += max(f[x][0], f[x][1]), g[fa[x]][1] += f[x][0]; x = fa[x]; &#125; printf("%d\n", max(f[1][0], f[1][1])); &#125; return 0;&#125; § 3 例题二=&gt; luogu 4751 动态dp【加强版】§ 3.1 题意同例题一。强制在线，每次操作给出 $x$，实际修改的点为 $x \oplus lastans$。 $n,m \leq 10^6$。 § 3.2 分析本题的数据范围要求了更优秀的复杂度。 考虑 LCT，复杂度 $O((n\log n+q\log n)$ 符合题目要求，但因常数过大而表现不理想。 由于本题不需要动态的 link，cut 以及换根操作，我们可以构造一种类似 LCT 的静态数据结构。 § 3.2.1 全局平衡二叉树类似 LCT，我们将树的每条重链用一棵辅助二叉树维护，辅助树之间用虚边连接。 每个节点维护所在重链的辅助树的子树矩阵积。 事实上前面的线段树也是一种类似的结构，但每棵都保证了局部的绝对平衡，导致单次复杂度为 $O(\log^2n)$。 所以我们需要找到一种合适的构造方法，做到所有辅助树全体的总深度平衡。 辅助树的构造方法： 定义点 $u$ 的权重 $w_u=size_u-size_{hson_u}$，即所有轻儿子的 $size$ 和 $+1$。 对于每条重链，以带权重心为辅助树根，左右递归构造即可。 容易证明，这样构造出的全局平衡二叉树的深度为 $O(\log n)$。 这样修改时只需在辅助树上单步向上跳并更新答案，跳虚边时更新父亲的 $g$ 值即可。 总时间复杂度为 $O(n\log n+q\log n)$。 § 3.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;namespace fastio&#123; const int BUFSIZE = (1 &lt;&lt; 22) + 1; char ibuf[BUFSIZE], *iS, *iT, obuf[BUFSIZE], *oS = obuf, *oT = obuf + BUFSIZE, ch; int stk[20], tops = 0, neg; inline char getch()&#123; if(iS != iT) return *iS++; iT = (iS = ibuf) + fread(ibuf, 1, BUFSIZE, stdin); return iS == iT ? EOF : *iS++; &#125; inline void flush() &#123;fwrite(obuf, 1, oS - obuf, stdout), oS = obuf;&#125; inline void putch(const char &amp;ch) &#123;*oS++ = ch; if(oS == oT) flush();&#125; #define isdgt(ch) ((ch) &gt;= '0' &amp;&amp; (ch) &lt;= '9') inline void getint(int &amp;num)&#123; neg = 0; while(!isdigit(ch = getch())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getch())) num = num * 10 + (ch &amp; 15); if(neg) num = -num; &#125; inline void putint(int num)&#123; if(!num) return putch('0'); if(num &lt; 0) putch('-'), num = -num; while(num) stk[++tops] = num % 10 | 48, num /= 10; while(tops) putch(stk[tops--]); &#125;&#125;using fastio::getint;using fastio::putint;using fastio::putch;int n, m, a[1000005], f[1000005][2], g[1000005][2], ch[1000005][2], root;int fa[1000005], siz[1000005], hson[1000005], top[1000005];int w[1000005], s[1000005], p[1000005];struct Edge &#123;int np; Edge *nxt;&#125; E[2000005], *V[1000005];inline void addedge(const int &amp;u, const int &amp;v)&#123; static int tope = 0; E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;&#125;struct Matrix&#123; int v[2][2]; inline Matrix() &#123;v[0][0] = v[1][1] = 0, v[0][1] = v[1][0] = -inf;&#125; inline Matrix(int g0, int g1) &#123;v[0][0] = v[0][1] = g0, v[1][0] = g1, v[1][1] = -inf;&#125; inline Matrix operator * (const Matrix &amp;mat) const &#123; static Matrix res; res.v[0][0] = max(v[0][0] + mat.v[0][0], v[0][1] + mat.v[1][0]); res.v[0][1] = max(v[0][0] + mat.v[0][1], v[0][1] + mat.v[1][1]); res.v[1][0] = max(v[1][0] + mat.v[0][0], v[1][1] + mat.v[1][0]); res.v[1][1] = max(v[1][0] + mat.v[0][1], v[1][1] + mat.v[1][1]); return res; &#125;&#125; F[1000005], G[1000005];inline void update(int u) &#123;F[u] = F[ch[u][0]] * G[u] * F[ch[u][1]];&#125;int build(int l, int r)&#123; if(l &gt; r) return 0; int smid = (s[l - 1] + s[r] + 1) &gt;&gt; 1, L = l, R = r; while(L &lt; R)&#123; const int mid = L + R &gt;&gt; 1; if(s[mid] &gt;= smid) R = mid; else L = mid + 1; &#125; const int u = p[L]; fa[ch[u][0] = build(l, L - 1)] = u, fa[ch[u][1] = build(L + 1, r)] = u; return update(u), u;&#125;void dfs1(int u)&#123; siz[u] = 1, hson[u] = 0, f[u][1] = a[u]; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u])&#123; fa[ne-&gt;np] = u, dfs1(ne-&gt;np), siz[u] += siz[ne-&gt;np]; if(siz[ne-&gt;np] &gt; siz[hson[u]]) hson[u] = ne-&gt;np; f[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), f[u][1] += f[ne-&gt;np][0]; &#125; w[u] = siz[u] - siz[hson[u]];&#125;void dfs2(int u)&#123; g[u][1] = a[u]; if(hson[u]) top[hson[u]] = top[u], dfs2(hson[u]); for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u] &amp;&amp; ne-&gt;np != hson[u])&#123; top[ne-&gt;np] = ne-&gt;np, dfs2(ne-&gt;np); g[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), g[u][1] += f[ne-&gt;np][0]; &#125; G[u] = Matrix(g[u][0], g[u][1]); if(top[u] == u)&#123; int cnt = 0, fu = fa[u]; for(register int v = u; v; v = hson[v]) p[++cnt] = v, s[cnt] = s[cnt - 1] + w[v]; fa[root = build(1, cnt)] = fu; &#125;&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(a[i]); for(register int i = 1; i &lt; n; i++)&#123; int u, v; getint(u), getint(v); addedge(u, v), addedge(v, u); &#125; dfs1(1), top[1] = 1, dfs2(1); int lastans = 0; while(m--)&#123; int x, y; getint(x), getint(y), x ^= lastans; g[x][1] += y - a[x], a[x] = y, G[x] = Matrix(g[x][0], g[x][1]); while(x)&#123; int z = fa[x]; if(ch[z][0] != x &amp;&amp; ch[z][1] != x) g[z][0] -= max(F[x].v[0][0], F[x].v[1][0]), g[z][1] -= F[x].v[0][0]; update(x); if(ch[z][0] != x &amp;&amp; ch[z][1] != x)&#123; g[z][0] += max(F[x].v[0][0], F[x].v[1][0]), g[z][1] += F[x].v[0][0]; G[z] = Matrix(g[z][0], g[z][1]); &#125; x = z; &#125; putint(lastans = max(F[root].v[0][0], F[root].v[1][0])), putch('\n'); &#125; return fastio::flush(), 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>动态DP</tag>
        <tag>树链剖分</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语假名随机测试器]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%97%A5%E8%AF%AD%E5%81%87%E5%90%8D%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[日语假名随机测试器，灵感来自机房巨魔 High_Cold 以及 Vishford。不定期更新。 Version 0.0.1: kana_v0.0.1.exe。 Version 0.1.0: kana_v0.1.0.exe，查看 README。 Version 0.2.0: kana_v0.2.0.exe，查看 README。]]></content>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烫烫烫烫烫烫烫]]></title>
    <url>%2F2018%2F10%2F25%2F%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%2F</url>
    <content type="text"><![CDATA[手持两把锟斤拷，口中疾呼烫烫烫。脚踏千朵屯屯屯，笑看万物锘锘锘。]]></content>
      <tags>
        <tag>OI-story</tag>
      </tags>
  </entry>
</search>
