<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[EZOI][1217NOI模拟赛]math(生成函数+分治FFT+高精度)]]></title>
    <url>%2F2018%2F12%2F19%2FEZOI-1217NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-math-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E5%88%86%E6%B2%BBFFT-%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[§ 1 题意对于集合 $S$，定义 $P(S)=\prod\limits_{x\in S}x$，即 $S$ 中元素之积。特别地，定义 $P(\emptyset)=1$。 记 $[n]=\lbrace 1,2,3,\cdots,n \rbrace$，对于 $n \in \mathbb{Z},\ 0\leq k\leq n$，定义 $F(n,k)=\sum\limits_{S\subseteq[n],\ |S|=k}P(S)$。 给定 $n​$ 以及质数 $p​$，求存在多少 $[0,n]​$ 上的整数 $k​$ 满足 $p\nmid F(n,k)​$，答案对 $998244353​$ 取模。 $1\leq n\leq 10^{1000},\ \ 2\leq p\leq 10^5$。 § 2 分析由题意可得， $F(n,k)$ 表示从 $1\sim n$ 中选出 $k$ 个相乘的值。考虑其生成函数，显然有 \begin{align} G_n&=\sum\limits_{i=0}^nF(n,i)·x^i \\ &\equiv\prod\limits_{i=1}^n(ix+1)\quad({\rm mod}\ p) \end{align}题目要求满足 $p\nmid F(n,k)$ 的整数 $k$ 的个数，就等价于求生成函数有多少项系数不为 $0$。 为简化计算，我们考虑将上式的高次项和低次项交换，得到 \begin{align} G_n^R\equiv\prod\limits_{i=1}^n(x+i)\quad({\rm mod}\ p) \end{align}该多项式系数不为 $0$ 的项数显然与原多项式相同。 令 $n=a·p+b$，则有 \begin{align} G_n^R\equiv\left(\prod\limits_{i=1}^p(x+i)\right)^a·\prod\limits_{i=1}^b(x+i)\quad({\rm mod}\ p) \end{align}考虑 $\prod\limits_{i=1}^p(x+i)$，可以发现该式在 ${\rm mod}\ p$ 意义下有且仅有 $p$ 个零点：$0,1,\cdots,p-1$。 由费马小定理可得 $x^{p-1}\equiv 1\quad({\rm mod}\ p)\ (0\lt x\lt p)$。 那么我们考虑 $x·(x^{p-1}-1)$，可以发现该式在 ${\rm mod\ p}$ 意义下有且仅有 $p$ 个零点：$0,1,\cdots,p-1$。 又有 $\prod\limits_{i=1}^p(x+i)$ 与 $x·(x^{p-1}-1)$ 都是 $p$ 次多项式，最高次均为 $1$，故能被 $p$ 个不同点确定。 所以 $\prod\limits_{i=1}^p(x+i)\equiv x·(x^{p-1}-1)\quad({\rm mod}\ p)$，于是有 \begin{align} G_n^R\equiv x^a·(x^{p-1}-1)^a·\prod\limits_{i=1}^b(x+i)\quad({\rm mod}\ p) \end{align} 首先考虑 $x^a$，对该项系数是否为 $0$ 无影响。 然后考虑 $(x^{p-1}-1)^a$，用二项式定理展开得 \begin{align} (x^{p-1}-1)^a=\sum\limits_{i=0}^a(-1)^{a-i}·x^{(p-1)·i}·\binom{a}{i} \end{align}发现只有 $\binom{a}{i}\not\equiv 0\ ({\rm mod}\ p)$ 时才有可能系数不为 $0$。 由 ${\rm Lucas}$ 定理可得 $\binom{a}{i}\equiv\binom{a\,\%\,p}{i\,\%\,p}·\binom{a\,/\,p}{i\,/\,p}$，即以 $p$ 进制分解组合数。 所以 $\binom{a}{i}\not\equiv 0\ ({\rm mod}\ p)$ 等价于 $p$ 进制下 $a$ 的每一位都不小于 $i$ 的同一位。 若 $a=\overline{a_ka_{k-1}\cdots a_0}_{(p)}$，则贡献为 $\prod\limits_{i=0}^k(a_i+1)$。 最后考虑 $\prod\limits_{i=1}^b(x+i)$。 若 $b\lt p-1$，由于 $(x^{p-1}-1)^a$ 中非 $0$ 项的次数一定为 $p-1$ 的倍数，而 $\prod\limits_{i=1}^b(x+i)$ 中非 $0$ 项的次数小于 $p-1$，一定不会出现重叠项。 那么原多项式中非 $0$ 项个数即为 $(x^{p-1}-1)^a$ 与 $\prod\limits_{i=1}^b(x+i)$ 非 $0$ 项个数之积。 后者直接分治 ${\rm FFT}$ 求解即可。 若 $b =p-1$，则 $\prod\limits_{i=1}^b(x+i)\equiv x^{p-1}-1\ ({\rm mod}\ p)$，证明同上。 计算 $(x^{p-1}-1)^a$ 时将 $a$ 加一即可。 使用 long double 版 ${\rm FFT}$ 即可通过，T老师的高精除法转 $p$ 进制代码精妙。 总时间复杂度为 $O(p\log^2p)$。 § 3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long double PI = acos(-1.0L);const int MOD = 998244353;struct cpl&#123; long double r, i; inline cpl operator + (const cpl &amp;rhs) const &#123;return (cpl)&#123;r + rhs.r, i + rhs.i&#125;;&#125; inline cpl operator - (const cpl &amp;rhs) const &#123;return (cpl)&#123;r - rhs.r, i - rhs.i&#125;;&#125; inline cpl operator * (const cpl &amp;rhs) const &#123;return (cpl)&#123;r * rhs.r - i * rhs.i, r * rhs.i + i * rhs.r&#125;;&#125;&#125; W[262150];char n[1005];int p, len, a[3333], cnt = 0, ans = 1, rev[262150];inline void carryBit()&#123; for(register int i = 1; i &lt;= cnt + 5; i++) a[i + 1] += a[i] / p, a[i] %= p; for(cnt += 5; !a[cnt]; cnt--);&#125;inline void FFT(vector&lt;cpl&gt; &amp;a, int lim, int f)&#123; a.resize(lim); for(register int i = 1; i &lt; lim; i++) if(i &lt; rev[i]) swap(a[i], a[rev[i]]); for(register int i = 1; i &lt; lim; i &lt;&lt;= 1)&#123; W[0] = (cpl)&#123;1, 0&#125;, W[1] = (cpl)&#123;cos(PI / i), f * sin(PI / i)&#125;; for(register int j = 2; j &lt; i; j++) W[j] = W[j - 1] * W[1]; for(register int j = 0; j &lt; lim; j += i &lt;&lt; 1) for(register int k = j; k &lt; j + i; k++)&#123; const cpl t = W[k - j] * a[k + i]; a[k + i] = a[k] - t, a[k] = a[k] + t; &#125; &#125; if(f == -1) for(register int i = 0; i &lt; lim; i++) a[i].r /= lim, a[i].i = 0;&#125;inline vector&lt;cpl&gt; mul(vector&lt;cpl&gt; f, vector&lt;cpl&gt; g)&#123; register int siz = f.size() + g.size() - 1, lim = 1, s = 0; while(lim &lt; siz) lim &lt;&lt;= 1, s++; for(register int i = 1; i &lt; lim; i++) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; (s - 1); FFT(f, lim, 1), FFT(g, lim, 1); for(register int i = 0; i &lt; lim; i++) f[i] = f[i] * g[i]; FFT(f, lim, -1), f.resize(siz); for(auto &amp;i: f) i.r = (long long)(i.r + 0.5) % p; return f;&#125;vector&lt;cpl&gt; solve(int l, int r)&#123; if(l == r)&#123; static vector&lt;cpl&gt; p(2); return p[0] = (cpl)&#123;(long double)l, 0&#125;, p[1] = (cpl)&#123;1, 0&#125;, p; &#125; const int mid = l + r &gt;&gt; 1; return mul(solve(l, mid), solve(mid + 1, r));&#125;int main()&#123; scanf("%s%d", n, &amp;p), len = strlen(n); for(register int i = 0; i &lt; len; i++)&#123; for(register int j = 1; j &lt;= cnt; j++) a[j] *= 10; a[1] += n[i] &amp; 15, carryBit(); &#125; // High-precise division (n / p) if(a[1] == p - 1) a[2]++, a[1] = 0, carryBit(); for(register int i = 2; i &lt;= cnt; i++) ans = ans * (a[i] + 1LL) % MOD; if(a[1])&#123; auto res = solve(1, a[1]); int cnt = 0; for(auto i: res) cnt += ((int)(i.r + 0.5) != 0); ans = ans * (long long)cnt % MOD; &#125; return printf("%d\n", ans), 0;&#125;]]></content>
      <tags>
        <tag>生成函数</tag>
        <tag>分治FFT</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1217NOI模拟赛]set(组合数学)]]></title>
    <url>%2F2018%2F12%2F18%2FEZOI-1217NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-set-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[§ 1 题意记 $[n]=\lbrace 1,2,3,\cdots,n \rbrace$，对于集合 $S$ 定义 $\min S=\min\limits_{x\in S}x,\ \ F(S)=T^{\min S}$。 给出 $n,\ m,\ T$，求 $E(F(S)\ |\ S\subseteq [n],\ |S|=k)$ 的值，答案对 $M=998244353$ 取模。 $1\leq k\leq n\lt M,\ \ 1\leq k\leq 10^7,\ \ 1\leq T\lt M$。 § 2 分析令 $A_k=\sum\limits_{S\subseteq [n],\ |S|=k}F(S)$，则所求的答案等于 $\frac{A_k}{\binom{n}{k}}$。 考虑从组合意义入手求解 $A_k$，我们从 $1\sim n$ 枚举 $\min S$ 的最小值。 若当前最小值为 $i$，则可从比 $i$ 大的 $n-i$ 个数中取剩余 $k-1$ 个，贡献为 $T^i·\binom{n-i}{k-1}$，故有 \begin{align} A_k=\sum\limits_{i=1}^nT^i·\binom{n-i}{k-1} \end{align}等式两边同乘 $T$ ，可得 \begin{align} TA_k&=\sum\limits_{i=1}^nT^{i+1}·\binom{n-i}{k-1} \\ &=\sum\limits_{i=2}^{n+1}T^i·\binom{n-i+1}{k-1} \end{align}两式相减，可得 \begin{align} (T-1)\,A_k&=\sum\limits_{i=2}^nT^i·\left[\binom{n-i+1}{k-1}-\binom{n-i}{k-1}\right]-T·\binom{n-1}{k-1} \\ &=\sum\limits_{i=2}^nT^i·\binom{n-i}{k-2}-T·\binom{n-1}{k-1} \\ &=\sum\limits_{i=1}^nT^i·\binom{n-i}{k-2}-T·\left[\binom{n-1}{k-2}+\binom{n-1}{k-1}\right] \\ &=A_{k-1}-T·\binom{n}{k-1} \end{align}考虑只需要先求出 $T-1$ 的逆元以及 $i=0\sim k-1$ 的 $\binom{n}{i}$ 即可 $O(n)$ 递推出 $A_k$。 其中后者只需要先 $O(n)$ 递推出 $0\sim k-1$ 的逆元，然后即可从 $\binom{n}{0}$ 开始递推得到。 注意 $T=1$ 的情况一定不要忘记特判！这种情况下上式左边会变成 $0·A_k$ 而无法计算，直接输出 $1$ 即可。 总时间复杂度为 $O(n)$。 § 3 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int M = 998244353;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, k, T, inv[10000002], Cn[10000002], A[10000002], Inv;inline ll fastpow(ll bas, ll ex)&#123; register ll res = 1; bas %= M; while(ex)&#123; if(ex &amp; 1) res = res * bas % M; bas = bas * bas % M, ex &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; getint(n), getint(k), getint(T); if(T == 1) return puts("1"), 0; inv[1] = 1, Cn[0] = 1, Inv = fastpow(T - 1, M - 2), A[1] = T * (fastpow(T, n) - 1LL + M) % M * Inv % M; for(register int i = 2; i &lt;= k; i++) inv[i] = (M - M / i) * (ll)inv[M % i] % M; for(register int i = 1; i &lt;= k; i++) Cn[i] = Cn[i - 1] * (n - i + 1LL) % M * (ll)inv[i] % M; for(register int i = 2; i &lt;= k; i++) A[i] = ((A[i - 1] - T * (ll)Cn[i - 1]) % M + M) * Inv % M; return printf("%d", A[k] * fastpow(Cn[k], M - 2) % M), 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1215NOI模拟赛]树(树形DP+贪心+枚举)]]></title>
    <url>%2F2018%2F12%2F17%2FEZOI-1215NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%A0%91-%E6%A0%91%E5%BD%A2DP-%E8%B4%AA%E5%BF%83-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[§ 1 题意给出三棵节点分别为 $n1,\ n2,\ n3$ 的树，再连两条边可构成一棵新树。 求可能形成的新树中，所有点对距离和的最大值。 $n1,\ n2,\ n3\leq 100000$。 § 2 分析对于其中一棵大小为 $n$ 的树，令 $dis_i$ 表示点 $i$ 到其他所有点的距离和，考虑如何快速求解 $dis_i$。 钦定点 $1$ 为根，不难发现 $dis_1=\sum\limits_{i\in V,\ i\neq 1}siz_i$，且有 $dis_i=dis_{fa_i}+n-2\,siz_i$。 所以可以先自底向上树形 DP 求出 $siz_i$，再自顶向下树形 DP 求出 $dis_i$。 考虑连一条边合并两棵树，要使所有点对距离和最大，一定贪心连接两棵树各自 $dis_i$ 最大的点。 所以尝试三种可能的合并方法，重新计算新生成的三棵树的 $dis_i$，与剩下的树合并取最大答案即可。 总时间复杂度为 $O(n1+n2+n3)$。 § 3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n1, n2, n3;struct Edge &#123;int np; Edge *nxt;&#125;;struct Tree&#123; int n, tope, siz[200005], mx; ll dis[200005]; Edge E[400005], *V[200005]; inline void addedge(const int &amp;u, const int &amp;v) &#123;E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;&#125; void dfs1(int u, int fa)&#123; siz[u] = 1; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa) dfs1(ne-&gt;np, u), siz[u] += siz[ne-&gt;np]; if(u != 1) dis[1] += siz[u]; &#125; void dfs2(int u, int fa)&#123; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa) dis[ne-&gt;np] = dis[u] + n - 2 * siz[ne-&gt;np], dfs2(ne-&gt;np, u); &#125; inline void getmax()&#123; mx = 1; for(register int i = 2; i &lt;= n; i++) if(dis[i] &gt; dis[mx]) mx = i; &#125;&#125; T[6];int main()&#123; getint(n1), getint(n2), getint(n3), T[0].n = n1, T[1].n = n2, T[2].n = n3; T[3].n = n1 + n2, T[4].n = n1 + n3, T[5].n = n2 + n3; for(register int i = 1; i &lt; n1; i++)&#123; register int u, v; getint(u), getint(v); T[0].addedge(u, v), T[0].addedge(v, u); T[3].addedge(u, v), T[3].addedge(v, u); T[4].addedge(u, v), T[4].addedge(v, u); &#125; for(register int i = 1; i &lt; n2; i++)&#123; register int u, v; getint(u), getint(v); T[1].addedge(u, v), T[1].addedge(v, u); T[3].addedge(u + n1, v + n1), T[3].addedge(v + n1, u + n1); T[5].addedge(u, v), T[5].addedge(v, u); &#125; for(register int i = 1; i &lt; n3; i++)&#123; register int u, v; getint(u), getint(v); T[2].addedge(u, v), T[2].addedge(v, u); T[4].addedge(u + n1, v + n1), T[4].addedge(v + n1, u + n1); T[5].addedge(u + n2, v + n2), T[5].addedge(v + n2, u + n2); &#125; for(register int i = 0; i &lt;= 2; i++) T[i].dfs1(1, 0), T[i].dfs2(1, 0), T[i].getmax(); T[3].addedge(T[0].mx, T[1].mx + n1), T[3].addedge(T[1].mx + n1, T[0].mx); T[4].addedge(T[0].mx, T[2].mx + n1), T[4].addedge(T[2].mx + n1, T[0].mx); T[5].addedge(T[1].mx, T[2].mx + n2), T[5].addedge(T[2].mx + n2, T[1].mx); for(register int i = 3; i &lt;= 5; i++) T[i].dfs1(1, 0), T[i].dfs2(1, 0), T[i].getmax(); ll ans = 0; for(register int i = 3, j = 2; i &lt;= 5; i++, j--)&#123; register ll cur = 0; for(register int k = 1; k &lt;= T[i].n; k++) cur += T[i].dis[k]; for(register int k = 1; k &lt;= T[j].n; k++) cur += T[j].dis[k]; (cur &gt;&gt;= 1) += T[i].n * (ll)T[j].dis[T[j].mx] + T[i].dis[T[i].mx] * (ll)T[j].n + T[i].n * (ll)T[j].n; ans = max(ans, cur); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>树形DP</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1214NOI模拟赛]graph(搜索+数学)]]></title>
    <url>%2F2018%2F12%2F17%2FEZOI-1214NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-graph-%E6%90%9C%E7%B4%A2-%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定一个点数为 $n$，边数为 $m$ 的无向图 $G=\lt V,E\gt$。 边 $(i,j)$ 有边权 $w_{i,j}$，点 $i$ 有点权 $p_i$，且对于 $\forall\ (i,j)\in E,\ \ p_i+p_j\geq w_{i,j}$。 现要将顶点 $i$ 的权值减去 $c_i\ (0\leq c_i\leq p_i)$，记修改后点权 $p’_i=p_i-c_i$，对于 $\forall\ (i,j)\in E,\ \ p’_i+p’_j=w_{i,j}$。 求满足条件的 $\sum\limits_{i\in V}c_i$ 的最小值和最大值，如果不存在则输出 ${\rm NIE}$。 保证给出的图中无重边无自环。 $n\leq 500000,\ m\leq 3000000,\ 0\leq p_i\leq 10^6,\ 0\leq w_{i,j}\leq 10^6$。 § 2 分析首先令 $w’_{i,j}=p_i+p_j-w_{i,j}$，表示每条边两端点减小的值之和。 考虑一个连通块，若一个点的 $c_i$ 确定，则所有点的 $c_i$ 都能确定。 不妨钦定一个根节点 $s$，令 $c_s=x$，则可 ${\rm bfs}$ 出每个点 $i$ 的 $d_i$ 和 ${\rm sgn}_i\ ({\rm sgn}_i=\pm 1)$ 值使得 $c_i=d_i+{\rm sgn}_i·x$。 若在 ${\rm bfs}$ 过程中若多次访问到同一个点，则需要判断是否矛盾： 设访问边 $(i,j)$ 时两端值均已求出，则有 $c_i=d_i+{\rm sgn}_i·x,\ \ c_j=d_j+{\rm sgn}_j·x,\ \ w’_{i,j}=c_i+c_j$。 若 ${\rm sgn}_i=-{\rm sgn}_j$，则 $w’_{i,j}=d_i+d_j$，若不符合该等式则矛盾，直接输出 ${\rm NIE}$。 若 ${\rm sgn}_i={\rm sgn}_j$，则 $w’_{i,j}=d_i+d_j+2\,{\rm sgn}_i·x$，可以用该方程解出 $x=\frac{w’_{i,j}-d_i-d_j}{2\,{\rm sgn}_i}$，若 $x$ 不为整数或多个类似情况中解出的 $x$ 不同则矛盾，直接输出 ${\rm NIE}$。 对一个连通块 ${\rm bfs}$ 完后，考虑每个点本身的限制： 对于 $\forall\ i\in V,\ \ 0\leq d_i+{\rm sgn}_i·x\leq p_i$， 若 ${\rm sgn}_i = 1$，则化简得 $-d_i\leq x\leq p_i-d_i$。 若 ${\rm sgn}_i = -1$，则化简得 $d_i-p_i\leq x\leq d_i$。 对所有限制取交集得到形如 $\min x\leq x\leq\max x$ 的区间。 若此时 $\min x&gt;\max x$ 则区间为空，输出 ${\rm NIE}$。 若之前有解出过 $x$ 的精确值，则判断 $x$ 是否在区间内，若不在区间内则矛盾，输出 ${\rm NIE}$。 最后答案为 $\sum\limits_{i\in V}c_i=\sum\limits_{i\in V}d_i+x\sum\limits_{i\in V}{\rm sgn}_i$，是一个常数或一次函数，易于统计最大值和最小值。 总时间复杂度为 $O(n+m)$。 注意 &amp;&amp; 是短路运算符，原来第 $42\sim44$ 行写了 123if(x &amp; 1) koware();if(~defx &amp;&amp; (x &gt;&gt;= 1) != defx) koware();defx = x; 结果 ${\rm WA}$ 成 $65$ 分 $(っ °Д °;)っ$，改成如下就 ${\rm AC}$ 了123if(x &amp; 1) koware(); else x &gt;&gt;= 1;if(~defx &amp;&amp; x != defx) koware();defx = x; § 3 代码注：c[i] 表示本文中的 ${\rm sgn}_i$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int MAXV = 500005, MAXE = 6000005;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;template &lt;typename T&gt; inline void checkmax(T &amp;a, const T &amp;b) &#123;if(a &lt; b) a = b;&#125;template &lt;typename T&gt; inline void checkmin(T &amp;a, const T &amp;b) &#123;if(b &lt; a) a = b;&#125;int n, m, p[MAXV], q[MAXV], c[MAXV];ll d[MAXV], minans, maxans; bool vis[MAXV];struct Edge &#123;int np, val; Edge *nxt;&#125; E[MAXE], *V[MAXV];inline void addedge(const int &amp;u, const int &amp;v, const int &amp;w)&#123; static int tope = 0; E[++tope].np = v, E[tope].val = w, E[tope].nxt = V[u], V[u] = E + tope;&#125;inline void koware() &#123;puts("NIE"), exit(0);&#125;inline void bfs(const int &amp;s)&#123; register int l = 0, r = 1, defx = -1; q[0] = s, c[s] = 1; while(l &lt; r)&#123; const int &amp;u = q[l++]; vis[u] = 1; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt)&#123; if(!c[ne-&gt;np]) c[ne-&gt;np] = -c[u], d[ne-&gt;np] = ne-&gt;val - d[u], q[r++] = ne-&gt;np; else if(!vis[ne-&gt;np])&#123; if(c[u] == c[ne-&gt;np])&#123; register ll x = (ne-&gt;val - d[u] - d[ne-&gt;np]) * c[u]; if(x &amp; 1) koware(); else x &gt;&gt;= 1; if(~defx &amp;&amp; x != defx) koware(); defx = x; &#125; else if(d[u] + d[ne-&gt;np] != ne-&gt;val) koware(); &#125; &#125; &#125; register ll minx = 0, maxx = p[s], sumc = 1, sumd = 0; for(register int i = 1; i &lt; r; i++)&#123; const int &amp;u = q[i]; if(c[u] == 1) checkmax(minx, -d[u]), checkmin(maxx, p[u] - d[u]); else checkmax(minx, d[u] - p[u]), checkmin(maxx, d[u]); sumc += c[u], sumd += d[u]; &#125; if(minx &gt; maxx) koware(); if(~defx)&#123; if(defx &lt; minx || defx &gt; maxx) koware(); minans += sumc * defx + sumd, maxans += sumc * defx + sumd; &#125; else&#123; if(sumc &gt;= 0) minans += sumc * minx + sumd, maxans += sumc * maxx + sumd; else minans += sumc * maxx + sumd, maxans += sumc * minx + sumd; &#125;&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(p[i]); for(register int i = 1; i &lt;= m; i++)&#123; int u, v, w; getint(u), getint(v), getint(w); addedge(u, v, p[u] + p[v] - w), addedge(v, u, p[u] + p[v] - w); &#125; for(register int i = 1; i &lt;= n; i++) if(!vis[i]) bfs(i); return printf("%lld %lld\n", minans, maxans), 0;&#125;]]></content>
      <tags>
        <tag>搜索</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1211NOI模拟赛]Lis(线段树+set)]]></title>
    <url>%2F2018%2F12%2F13%2FEZOI-1211NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-Lis-%E7%BA%BF%E6%AE%B5%E6%A0%91-set%2F</url>
    <content type="text"><![CDATA[§ 1 题意街道上有 $n$ 个位置可用来种树，自西向东标号为 $1 \sim n$。 共 $m$ 个月，在第 $i$ 个月的开始，有以下操作之一： 在编号为 $p_i$ 的位置种植一棵高度为 $h_i$ 米的树，保证每个位置只会出现一次。 砍倒自西向东数第 $x_i$ 棵树，保证存在。 其中栽下的树木每月长高 $1$ 米，且保证任意时刻没有两棵树的高度相同。 求每次操作后输出树高序列的最长上升子序列长度。 $n \leq 10^5,m \leq 10^5, p_i \leq n,1 \leq h_i \leq 10,x_i \leq 10$。 § 2 分析首先考虑操作 $1$，由于 $1 \leq h_i \leq 10$ 且树木每月长高 $1$ 米，故 $10$ 个月及以前种植的树一定高于当前树。 令 ${\rm LIS}_i$ 表示以位置 $i$ 的树开头的最长上升子序列长度。 考虑用队列存最后种植的 $10$ 棵树，然后以位置为下标建立线段树维护其余的 ${\rm LIS}_i$ 最大值。 在位置 $p$ 种植高度为 $h$ 的树时，先将队列中最早种植的树的 ${\rm LIS}_i$ 插入“位置线段树”，并在队列中删除；然后用“位置线段树”中的后缀 $\max$ 更新当前树，并加入队列；最后 $O(10^2)$ 暴力更新队列中的树的 ${\rm LIS}_i$ 即可。 然后考虑操作 $2$，发现删除自西向东第 $x_i$ 棵树只会影响第 $1 \sim x_i-1$ 棵树的 ${\rm LIS}_i$。 题目保证任意时刻没有高度相同的树，考虑以高度为下标建立线段树维护全局 ${\rm LIS}_i$ 最大值。 由于 $1 \leq x_i \leq 10$，我们可以在种树时直接把位置存到一个 set 里，那么删除时只需先把前 $x_i$ 棵全取出，并在“高度线段树”中先将其去除；然后把要删除的第 $x_i$ 棵在 set 和“位置线段树”中去除；最后倒序遍历前 $x_i-1$ 棵树，用“高度线段树”中的后缀 $\max$ 更新后，重新插入“高度线段树”（倒序可以保证一棵树不被前面的树更新）。 最后一定要注意细节，总时间复杂度为 $O(m\log m+10\,m\log n)​$。 § 3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;inline void checkmax(int &amp;a, const int &amp;b) &#123;if(a &lt; b) a = b;&#125;int n, m, h[100005];int q[100005], inq[100005], fr, re, lis[100005], del[100005];int tmp[100005], cnt;set&lt;int&gt; s; set&lt;int&gt;::iterator it;struct Segtree&#123; int mx[400050]; #define lch (u &lt;&lt; 1) #define rch (u &lt;&lt; 1 | 1) inline void modify(int u, int l, int r, int p, int v)&#123; while(l &lt; r)&#123; const int mid = l + r &gt;&gt; 1; if(p &lt;= mid) u = lch, r = mid; else u = rch, l = mid + 1; &#125; mx[u] = v; while(u &gt;&gt;= 1) mx[u] = max(mx[lch], mx[rch]); &#125; int query(int u, int l, int r, int ql, int qr)&#123; if(ql &gt; qr) return 0; if(l == ql &amp;&amp; r == qr) return mx[u]; const int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(lch, l, mid, ql, qr); if(ql &gt; mid) return query(rch, mid + 1, r, ql, qr); return max(query(lch, l, mid, ql, mid), query(rch, mid + 1, r, mid + 1, qr)); &#125;&#125; P, H;int main()&#123; getint(n), getint(m); for(register int gatsu = 1; gatsu &lt;= m; gatsu++)&#123; int opt, p; getint(opt), getint(p); if(opt == 1)&#123; getint(h[p]), h[p] += m - gatsu; s.insert(p), q[re++] = p, inq[p] = 1, del[p] = 0; if(re - fr &gt; 10)&#123; if(!del[q[fr]]) P.modify(1, 1, n, q[fr], lis[q[fr]]); inq[q[fr++]] = 0; &#125; lis[p] = P.query(1, 1, n, p + 1, n) + 1, cnt = 0; for(register int i = fr; i != re; i++) if(!del[q[i]]) tmp[++cnt] = q[i]; sort(tmp + 1, tmp + cnt + 1); for(register int i = cnt; i; i--)&#123; for(register int j = i + 1; j &lt;= cnt; j++) if(h[tmp[i]] &lt; h[tmp[j]]) checkmax(lis[tmp[i]], lis[tmp[j]] + 1); H.modify(1, 1, m + 10, h[tmp[i]], lis[tmp[i]]); &#125; &#125; else&#123; tmp[cnt = 1] = *(it = s.begin()), H.modify(1, 1, m + 10, h[*it], 0); for(register int i = 2; i &lt;= p; i++) tmp[++cnt] = *++it, H.modify(1, 1, m + 10, h[*it], 0); P.modify(1, 1, n, *it, 0), del[*it] = 1, s.erase(it); while(--cnt)&#123; lis[tmp[cnt]] = H.query(1, 1, m + 10, h[tmp[cnt]] + 1, m + 10) + 1; H.modify(1, 1, m + 10, h[tmp[cnt]], lis[tmp[cnt]]); if(!inq[tmp[cnt]]) P.modify(1, 1, n, tmp[cnt], lis[tmp[cnt]]); &#125; &#125; printf("%d\n", H.mx[1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1211NOI模拟赛]LCM(根号分治+容斥)]]></title>
    <url>%2F2018%2F12%2F12%2FEZOI-1211NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-LCM-%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB-%E5%AE%B9%E6%96%A5%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定一个大小为 $n$ 的数集 $S$，求 $\sum\limits_{S’ \subseteq S,S’ \neq \emptyset} {\rm LCM}(S’)$，即 $S$ 所有非空子集的 ${\rm LCM}$ 和。 $n \leq 2000,a_i \leq 200$。 § 2 分析首先发现 $a_i \leq 200$ 很小，考虑是否可以分解质因数统计。但 $200$ 以内的质数有 $46$ 个，组成的 ${\rm LCM}$ 值域过大。 考虑根号分治，观察发现 $\gt \sqrt{a_i} \approx 14$ 的质数的幂次最高为 $1$，而 $\leq 14$ 的质数只有 $6$ 个，分别为 $2,3,5,7,11,13$，其最高幂次分别为 $7,4,3,2,2,2$。 所以若只考虑 $2,3,5,7,11,13$，则 ${\rm LCM}$ 的不同值至多只有 $8\times5\times4\times3\times3\times3=4320$ 种。 我们将 $a_i$ 按除完 $2,3,5,7,11,13$ 后剩下的值 $c_i$ 分类，可以证明 $c_i=1 $ 或 $\gt 13$ 的质数。 令 $f_{c,p_1,p_2,p_3,p_4,p_5,p_6}$ 表示除完后剩下的值为 $c$ 时，是 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 因数的数的个数： 12345678for(register int i = 1; i &lt;= n; i++) for(register int p1 = a[i][1]; p1 &lt;= mx[1]; p1++) for(register int p2 = a[i][2]; p2 &lt;= mx[2]; p2++) for(register int p3 = a[i][3]; p3 &lt;= mx[3]; p3++) for(register int p4 = a[i][4]; p4 &lt;= mx[4]; p4++) for(register int p5 = a[i][5]; p5 &lt;= mx[5]; p5++) for(register int p6 = a[i][6]; p6 &lt;= mx[6]; p6++) f[c[i]][p1][p2][p3][p4][p5][p6]++; 令 $g_{p1,p2,p3,p4,p5,p6}$ 表示不考虑 $\gt 13$ 的因子时 ${\rm LCM}$ 为 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 的因数的子集数。 首先考虑除完后剩下的值 $c=1$ 时，$F=f_{1,p_1,p_2,p_3,p_4,p_5,p_6}$ 个数中的每个要么选要么不选，共有 $2^F$ 种可能： 1234567for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) g[p1][p2][p3][p4][p5][p6] = bin[f[1][p1][p2][p3][p4][p5][p6]]; 然后考虑除完后剩下的值 $c\gt 13$ 时，$F=f_{c,p_1,p_2,p_3,p_4,p_5,p_6}$ 个数中，都不选有 $1$ 种可能，选至少一个都会导致 ${\rm LCM}$ 扩大 $c$ 倍，由于只需统计 ${\rm LCM}$ 的和，可将一种算作 $c$ 种，等价于共有 $1+c\times(2^F-1)$ 种可能： 12345678910for(register int i = 1; i &lt;= 40; i++)&#123; const int &amp;r = rem[i]; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) (g[p1][p2][p3][p4][p5][p6] *= (r * (bin[f[r][p1][p2][p3][p4][p5][p6]] - 1LL + MOD) + 1LL) % MOD) %= MOD;&#125; 接下来通过容斥原理即可将 $g_{p1,p2,p3,p4,p5,p6}$ 转化为不考虑 $\gt 13$ 的因子时 ${\rm LCM}$ 严格等于 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 的子集数，注意容斥要从大到小进行： 12345678910111213141516for(register int p1 = mx[1]; ~p1; p1--) for(register int p2 = mx[2]; ~p2; p2--) for(register int p3 = mx[3]; ~p3; p3--) for(register int p4 = mx[4]; ~p4; p4--) for(register int p5 = mx[5]; ~p5; p5--) for(register int p6 = mx[6]; ~p6; p6--) for(register int d1 = 0; d1 &lt;= 1 &amp;&amp; d1 &lt;= p1; d1++) for(register int d2 = 0; d2 &lt;= 1 &amp;&amp; d2 &lt;= p2; d2++) for(register int d3 = 0; d3 &lt;= 1 &amp;&amp; d3 &lt;= p3; d3++) for(register int d4 = 0; d4 &lt;= 1 &amp;&amp; d4 &lt;= p4; d4++) for(register int d5 = 0; d5 &lt;= 1 &amp;&amp; d5 &lt;= p5; d5++) for(register int d6 = 0; d6 &lt;= 1 &amp;&amp; d6 &lt;= p6; d6++) if(d1 | d2 | d3 | d4 | d5 | d6)&#123; if(d1 ^ d2 ^ d3 ^ d4 ^ d5 ^ d6) (g[p1][p2][p3][p4][p5][p6] += MOD - g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; else (g[p1][p2][p3][p4][p5][p6] += g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; &#125; 最后答案即为 $\sum\limits_{p1,p2,p3,p4,p5,p6}2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}\times g_{p1,p2,p3,p4,p5,p6}$ 减去 $1$，即除去空集。 总时间复杂度为 $O(8\times5\times4\times3\times3\times3\times(n+40+2^6))​$。 § 3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MOD 1000000007using namespace std;typedef long long ll;const int prm[7] = &#123;1, 2, 3, 5, 7, 11, 13&#125;;const int rem[41] = &#123;1, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199&#125;;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, mx[7], a[2005][7], c[2005], v[8][5][4][3][3][3], f[205][8][5][4][3][3][3], bin[2005], ans;ll g[8][5][4][3][3][3];int main()&#123; getint(n), bin[0] = 1; for(register int i = 1; i &lt;= n; i++) bin[i] = (bin[i - 1] &lt;&lt; 1) % MOD; for(register int i = 1; i &lt;= n; i++)&#123; int v; getint(v); for(register int j = 1; j &lt;= 6; j++) while(v % prm[j] == 0)&#123; if(++a[i][j] &gt; mx[j]) mx[j] = a[i][j]; v /= prm[j]; &#125; c[i] = v; &#125; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++)&#123; if(p1) v[p1][p2][p3][p4][p5][p6] = v[p1 - 1][p2][p3][p4][p5][p6] * 2 % MOD; else if(p2) v[p1][p2][p3][p4][p5][p6] = v[p1][p2 - 1][p3][p4][p5][p6] * 3 % MOD; else if(p3) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3 - 1][p4][p5][p6] * 5 % MOD; else if(p4) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4 - 1][p5][p6] * 7 % MOD; else if(p5) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4][p5 - 1][p6] * 11 % MOD; else if(p6) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4][p5][p6 - 1] * 13 % MOD; else v[p1][p2][p3][p4][p5][p6] = 1; &#125; // 预处理 2^p1 * 3^p2 * 5^p3 * 7^p4 * 11^p5 * 13^p6 的值 for(register int i = 1; i &lt;= n; i++) for(register int p1 = a[i][1]; p1 &lt;= mx[1]; p1++) for(register int p2 = a[i][2]; p2 &lt;= mx[2]; p2++) for(register int p3 = a[i][3]; p3 &lt;= mx[3]; p3++) for(register int p4 = a[i][4]; p4 &lt;= mx[4]; p4++) for(register int p5 = a[i][5]; p5 &lt;= mx[5]; p5++) for(register int p6 = a[i][6]; p6 &lt;= mx[6]; p6++) f[c[i]][p1][p2][p3][p4][p5][p6]++; // 按 c[i] 分组统计可能对 LCM = 2^p1 * 3^p2 * 5^p3 * 7^p4 * 11^p5 * 13^p6 有贡献的数的个数 for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) g[p1][p2][p3][p4][p5][p6] = bin[f[1][p1][p2][p3][p4][p5][p6]]; // c[i] = 1 的对答案贡献倍数为 2^f for(register int i = 1; i &lt;= 40; i++)&#123; const int &amp;r = rem[i]; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) (g[p1][p2][p3][p4][p5][p6] *= (r * (bin[f[r][p1][p2][p3][p4][p5][p6]] - 1LL + MOD) + 1LL) % MOD) %= MOD; &#125; // c[i] &gt; 13 的对答案贡献倍数为 1 + (c[i] * 2^f - 1) for(register int p1 = mx[1]; ~p1; p1--) for(register int p2 = mx[2]; ~p2; p2--) for(register int p3 = mx[3]; ~p3; p3--) for(register int p4 = mx[4]; ~p4; p4--) for(register int p5 = mx[5]; ~p5; p5--) for(register int p6 = mx[6]; ~p6; p6--) for(register int d1 = 0; d1 &lt;= 1 &amp;&amp; d1 &lt;= p1; d1++) for(register int d2 = 0; d2 &lt;= 1 &amp;&amp; d2 &lt;= p2; d2++) for(register int d3 = 0; d3 &lt;= 1 &amp;&amp; d3 &lt;= p3; d3++) for(register int d4 = 0; d4 &lt;= 1 &amp;&amp; d4 &lt;= p4; d4++) for(register int d5 = 0; d5 &lt;= 1 &amp;&amp; d5 &lt;= p5; d5++) for(register int d6 = 0; d6 &lt;= 1 &amp;&amp; d6 &lt;= p6; d6++) if(d1 | d2 | d3 | d4 | d5 | d6)&#123; if(d1 ^ d2 ^ d3 ^ d4 ^ d5 ^ d6) (g[p1][p2][p3][p4][p5][p6] += MOD - g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; else (g[p1][p2][p3][p4][p5][p6] += g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; &#125; // 通过容斥将"小于等于"转化为严格等于 for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) ans = (ans + g[p1][p2][p3][p4][p5][p6] * v[p1][p2][p3][p4][p5][p6]) % MOD; printf("%d\n", (ans + MOD - 1) % MOD); return 0;&#125;]]></content>
      <tags>
        <tag>根号分治</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1211NOI模拟赛]Xor(线性基)]]></title>
    <url>%2F2018%2F12%2F12%2FEZOI-1211NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-Xor-%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定简单无向连通带权图 $G=\lt V,E\gt$，其中对于 $u \in V$ 有点权 $W_u$，对于 $(i,j) \in E$ 有边权 $w_{i,j}$。 定义边集 $E$ 的权值为 $\bigoplus\limits_{(i,j) \in E} w_{i,j}$。 若一个割 $C$ 将图 $G$ 的点集 $V$ 分成 $S,T$ 两部分，其中 $S \cup T=V$，则简记为 $C=\lt S,T\gt$。 定义一个割 $C$ 是合法的，当且仅当对于 $\forall S’ \subseteq S,S’ \neq \emptyset$，割边集 $C’=\lt S’,T’\gt(T’=V-S’)$ 的权值均非 $0$。 求合法割集中 $\sum\limits_{u \in S}W_u-\sum\limits_{u \in T}W_u$ 的最大值。 $n \leq 10^5,m \leq 2*10^5,W_u \leq 10^{12},w_{i,j} \lt 2^{63}$。 § 2 分析边 $(i,j)$ 在割集 $C=\lt S,T\gt$ 中，当且仅当它的一个端点在 $S$ 中，另一个在 $T$ 中。此时割集权值要异或 $w_{i,j}$。 如果边 $(i,j)$ 的两个端点均在 $S$ 中，可以视作割集权值异或两次 $w_{i,j}$，等价于没有贡献。 记点 $u$ 所有出边的边权异或和 $f_u=\bigoplus\limits_{(u,i) \in E} w_{u,i}$，则割 $C=\lt S,T\gt$ 的权值为 $\bigoplus\limits_{u \in S}f_u$。 由于合法割集需要满足不存在 $S’ \subseteq S,S’ \neq \emptyset$ 使得割 $C’=\lt S’,V-S’\gt$ 权值为 $0$，所以 $S$ 中的点的 $f_u$ 要线性无关，使用线性基按 $W_u$ 从大到小贪心即可。 总时间复杂度为 $O(n\log w)$。 § 3 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;template &lt;typename T&gt; inline void getint(T &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, m; ll bas[63], tot = 0, ans = 0;struct Node &#123;ll w, f;&#125; p[100005];inline bool operator &lt; (const Node &amp;p1, const Node &amp;p2) &#123;return p1.w &gt; p2.w;&#125;inline int ins(ll val)&#123; for(register int i = 62; ~i; i--) if(val &amp; (1LL &lt;&lt; i)) if(bas[i]) val ^= bas[i]; else return bas[i] = val, 1; return 0;&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(p[i].w), tot += p[i].w; for(register int i = 1; i &lt;= m; i++)&#123; int u, v; ll w; getint(u), getint(v), getint(w); p[u].f ^= w, p[v].f ^= w; &#125; sort(p + 1, p + n + 1); for(register int i = 1; i &lt;= n; i++) if(ins(p[i].f)) ans += p[i].w; printf("%lld\n", ans * 2 - tot); return 0;&#125;]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1208NOI模拟赛]Forest(multiset)]]></title>
    <url>%2F2018%2F12%2F10%2FEZOI-1208NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-Forest-multiset%2F</url>
    <content type="text"><![CDATA[§ 1 题意有一个点数为 $n$ 的有向图，每个点出度均为 $1$。 给出每个点的后继 $A_i$ 和点权 $B_i$，保证 $A_i \neq i$ 且 $A_{A_i} \neq i$。 记点 $i$ 的总度数为 $D_i$，并定义 $E_i = \lfloor \frac{B_i}{D_i} \rfloor$，稠密度 $C_i=B_i-D_i*E_i+\sum_{j=1}^{D_i}E_{P_j}$。 请实现一个稠密度分析仪，支持以下三种操作： $1$ $i$ $j$ ：把 $i$ 点的后继改为 $j$，即令 $A_i=j$，保证 $j \neq i$ 且 $A_j \neq i$。 $2​$ $i​$ ：询问 $i​$ 点的稠密度 $C_i​$。 $3$ ：询问所有节点中，$C_i$ 的最小值和最大值。 $3 \leq n \leq 10^5$，$1 \leq q \leq 10^5$，$1 \leq B_i \leq 10^{12}$，$1 \leq A_i \leq n$。 题目来源：Codeforces 643D - Bearish Fanpages。 § 2 分析首先化简得 $C_i=B_i \% D_i+\sum_{j=1}^{D_i}E_{P_j}$。 考虑操作 $1$，将点 $i$ 的后继从 $A_i$ 改为 $j$，若 $A_i==j$ 则跳过，否则考虑改动所造成的影响： $A_i$ 的度数减少 $1$，即 $D_{A_i}$ 减去 $1$，导致 $E_{A_i} = \lfloor \frac{B_{A_i}}{D_{A_i}} \rfloor$ 改变。 $j$ 的度数增加 $1$，即 $D_j$ 加上 $1$，导致 $E_j = \lfloor \frac{B_j}{D_j} \rfloor$ 改变。 连边情况改变，即最后令 $A_i=j​$。 当某个 $E_i$ 改变时，$C_{i}$、$C_{A_i}$ 以及 $i$ 所有前驱 $j$ 的 $C_j$ 都要改变。 § 2.1 弱化版若没有 $3$ 操作，则我们考虑维护 $C’_i=C_i-E_{A_i}$，即不计后继贡献时的答案。 执行 $1$ $i$ $j$ 操作时，由于不计后继贡献， $C’_i$ 不会改变，重算 $E_{A_i}$ 和 $E_j$，更新 $C’_{A_i}$、$C’_{A_{A_i}}$、$C’_j$ 和 $C’_{A_j}$。 执行 $2$ $i$ 操作时，直接输出 $C’_i+E_{A_i}$ 即可。 总体可在 $O(n)$ 时间内解决。 § 2.2 维护极值考虑 $3$ 操作，我们可以对每个节点 $i$ 用 multiset 维护其前驱 $C’_i$ 的极值，然后取每个 multiset 中的极值再放入 multiset 中维护，即可在 $O(n\log n)$ 时间内解决本题。 注意每次更新 $C’_i$ 时，先在维护总体极值的 multiset 中删除，然后在父节点的 multiset 中删除，修改 $C’_i$ 后再在父节点的 multiset 中插入，最后在总体极值的 multiset 中插入即可。 § 3 代码注：C[i] 表示本文中的 $C’_i$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;typedef long long ll;template &lt;typename T&gt; inline void getint(T &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, q, A[100005], D[100005];ll B[100005], E[100005], C[100005];multiset&lt;ll&gt; s[100005], maxs, mins;inline void ins(const int &amp;u)&#123; if(s[u].empty()) return; maxs.insert(*s[u].rbegin() + E[u]); mins.insert(*s[u].begin() + E[u]);&#125;inline void del(const int &amp;u)&#123; if(s[u].empty()) return; maxs.erase(maxs.find(*s[u].rbegin() + E[u])); mins.erase(mins.find(*s[u].begin() + E[u]));&#125;int main()&#123; getint(n), getint(q); for(register int i = 1; i &lt;= n; i++) getint(B[i]), D[i] = 2; for(register int i = 1; i &lt;= n; i++) getint(A[i]), D[A[i]]++; for(register int i = 1; i &lt;= n; i++) E[i] = B[i] / D[i], C[i] = B[i] % D[i] + E[i]; for(register int i = 1; i &lt;= n; i++) C[A[i]] += E[i]; for(register int i = 1; i &lt;= n; i++) s[A[i]].insert(C[i]); for(register int i = 1; i &lt;= n; i++) ins(i); while(q--)&#123; int opt, u, v; getint(opt); if(opt == 1)&#123; getint(u), getint(v); if(A[u] == v) continue; int p = A[u], q = A[p], r = A[q]; del(p), s[p].erase(s[p].find(C[u])); del(q), s[q].erase(s[q].find(C[p])); del(r), s[r].erase(s[r].find(C[q])); C[p] -= B[p] % D[p] + E[u] + E[p], C[q] -= E[p]; E[p] = B[p] / --D[p]; C[p] += B[p] % D[p] + E[p], C[q] += E[p]; ins(p); s[q].insert(C[p]), ins(q); s[r].insert(C[q]), ins(r); p = A[u] = v, q = A[p], r = A[q]; del(p); del(q), s[q].erase(s[q].find(C[p])); del(r), s[r].erase(s[r].find(C[q])); C[p] -= B[p] % D[p] + E[p], C[q] -= E[p]; E[p] = B[p] / ++D[p]; C[p] += B[p] % D[p] + E[u] + E[p], C[q] += E[p]; s[p].insert(C[u]), ins(p); s[q].insert(C[p]), ins(q); s[r].insert(C[q]), ins(r); &#125; else if(opt == 2) getint(u), printf("%lld\n", C[u] + E[A[u]]); else if(opt == 3) printf("%lld %lld\n", *mins.begin(), *maxs.rbegin()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈动态DP]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81DP%2F</url>
    <content type="text"><![CDATA[§ 1 前言本文大量参考 txc 巨爷的《基于变换合并的树上动态DP的链分治算法和全局平衡二叉树学习笔记》一文。在某些问题中，我们需要实现对某种 DP 的权值修改，以及快速询问全局或子结构的 DP 值。 如果我们能找到一种满足结合律的运算来描述转移过程的话，就可以用数据结构维护合并，降低复杂度。 § 2 例题一=&gt; luogu 4719 【模板】动态dp§ 2.1 题意给定一棵有 $i$ 个点的树，第 $i$ 个点的点权为 $a_i$。 有 $m$ 次操作，每次操作给定 $x,y$，表示将点 $x$ 的权值修改为 $y$。 求每次操作后这棵树的最大权独立集的权值，其中独立集指任意两个顶点不相邻的点集。 $n,m \leq 10^5$。 § 2.2 分析本题的模型为树上带修最大权独立集，是动态 DP 的模板题。 § 2.2.1 弱化版首先考虑如果没有修改操作，我们可以直接进行 $\Theta(n)$ 的树形 DP。 令 $f_{u,0/1}$ 表示以 $u$ 为根的子树中，不选 / 选 $u$ 时的最大权独立集的权值，则有 \begin{align} f_{u,0}&=\sum_{u→v}max\{f_{v,0},f_{v,1}\} \\ f_{u,1}&=a_u+\sum_{u→v}f_{v,0}\end{align}§ 2.2.2 重写转移考虑树链剖分，求出 $u$ 的重儿子 $hson_u$。单独取出重儿子贡献的一项，则 DP 转化为 \begin{align} f_{u,0}&=max\{f_{hson_u,0},f_{hson_u,1}\}+\sum_{u→v,v\neq hson_u}max\{f_{v,0},f_{v,1}\} \\ f_{u,1}&=a_u+f_{hson_u,0}+\sum_{u→v,v\neq hson_u}f_{v,0}\end{align}记 \begin{align} g_{u,0}&=\sum_{u→v,v\neq hson_u}max\{f_{v,0},f_{v,1}\} \\ g_{u,1}&=a_u+\sum_{u→v,v\neq hson_u}f_{v,0}\end{align}则有 \begin{align} f_{u,0}&=max\{f_{hson_u,0},f_{hson_u,1}\}+g_{u,0} \\ f_{u,1}&=f_{hson_u,0}+g_{u,1}\end{align}§ 2.2.3 矩阵优化我们重新定义矩阵乘法 $C=A*B$ 来描述这个转移，令 $\begin{align} c_{i,j}=\max \limits_k(a_{i,k}+b_{k,j}) \end{align} $ 则转移可写为 \begin{equation} \left( \begin{array}{c} f_{u,0} \\ f_{u,1} \end{array} \right)= \left( \begin{array}{cc} g_{u,0} & g_{u,0} \\ g_{u,1} & -\infty \end{array} \right) \left( \begin{array}{c} f_{hson_u,0} \\ f_{hson_u,1} \end{array} \right) \end{equation}可以证明重定义的矩阵乘法是具有结合律的，且存在单位矩阵\begin{equation}\left( \begin{array}{cc} 0 & -\infty \\ -\infty & 0 \end{array} \right) \end{equation}。 求一个点的 DP 值时，只需将该点沿重链走到底的矩阵相乘即可。 由于重链在 dfs 序上连续，可以用线段树维护区间矩阵乘积。修改类似树链剖分，重复以下步骤： 更新当前点的矩阵； 跳到重链顶端，同时计算 DP 值，更新父节点的 $g$ 值，并跳到父节点。 这样单次修改复杂度为 $O(\log^2n)$，查询复杂度为 $O(\log n)$。 § 2.3 代码注：leafdfn[u] 表示点 $u​$ 所在重链底部节点的 dfs 序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, m, a[100005], f[100005][2], g[100005][2];int fa[100005], siz[100005], hson[100005];int dfn[100005], dfstime = 0, id[100005], top[100005], leafdfn[100005];struct Edge &#123;int np; Edge *nxt;&#125; E[200005], *V[100005];inline void addedge(const int &amp;u, const int &amp;v)&#123; static int tope = 0; E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;&#125;struct Matrix&#123; int v[2][2]; inline Matrix() &#123;v[0][0] = v[1][1] = 0, v[0][1] = v[1][0] = -inf;&#125; inline Matrix(int g0, int g1) &#123;v[0][0] = v[0][1] = g0, v[1][0] = g1, v[1][1] = -inf;&#125; inline Matrix operator * (const Matrix &amp;mat) const&#123; static Matrix res; res.v[0][0] = max(v[0][0] + mat.v[0][0], v[0][1] + mat.v[1][0]); res.v[0][1] = max(v[0][0] + mat.v[0][1], v[0][1] + mat.v[1][1]); res.v[1][0] = max(v[1][0] + mat.v[0][0], v[1][1] + mat.v[1][0]); res.v[1][1] = max(v[1][0] + mat.v[0][1], v[1][1] + mat.v[1][1]); return res; &#125;&#125; s[400005];void dfs1(int u)&#123; siz[u] = 1, hson[u] = 0, f[u][1] = a[u]; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u])&#123; fa[ne-&gt;np] = u, dfs1(ne-&gt;np), siz[u] += siz[ne-&gt;np]; if(siz[ne-&gt;np] &gt; siz[hson[u]]) hson[u] = ne-&gt;np; f[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), f[u][1] += f[ne-&gt;np][0]; &#125;&#125;void dfs2(int u)&#123; id[dfn[u] = ++dfstime] = u, g[u][1] = a[u]; if(hson[u]) top[hson[u]] = top[u], dfs2(hson[u]), leafdfn[u] = leafdfn[hson[u]]; else leafdfn[u] = dfstime; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u] &amp;&amp; ne-&gt;np != hson[u])&#123; top[ne-&gt;np] = ne-&gt;np, dfs2(ne-&gt;np); g[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), g[u][1] += f[ne-&gt;np][0]; &#125;&#125;#define lch (u &lt;&lt; 1)#define rch (u &lt;&lt; 1 | 1)void build(int u, int l, int r)&#123; if(l == r) &#123;s[u] = Matrix(g[id[l]][0], g[id[l]][1]); return;&#125; const int mid = l + r &gt;&gt; 1; build(lch, l, mid), build(rch, mid + 1, r); s[u] = s[lch] * s[rch];&#125;void modify(int u, int l, int r, int pos)&#123; if(l == r) &#123;s[u] = Matrix(g[id[l]][0], g[id[l]][1]); return;&#125; const int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) modify(lch, l, mid, pos); else modify(rch, mid + 1, r, pos); s[u] = s[lch] * s[rch];&#125;Matrix query(int u, int l, int r, int ql, int qr)&#123; if(l == ql &amp;&amp; r == qr) return s[u]; const int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(lch, l, mid, ql, qr); if(ql &gt; mid) return query(rch, mid + 1, r, ql, qr); return query(lch, l, mid, ql, mid) * query(rch, mid + 1, r, mid + 1, qr);&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(a[i]); for(register int i = 1; i &lt; n; i++)&#123; int u, v; getint(u), getint(v); addedge(u, v), addedge(v, u); &#125; dfs1(1), top[1] = 1, dfs2(1); build(1, 1, n); while(m--)&#123; int x, y; getint(x), getint(y); g[x][1] += y - a[x], a[x] = y; while(x)&#123; modify(1, 1, n, dfn[x]), x = top[x]; Matrix res = query(1, 1, n, dfn[x], leafdfn[x]); g[fa[x]][0] -= max(f[x][0], f[x][1]), g[fa[x]][1] -= f[x][0]; f[x][0] = res.v[0][0], f[x][1] = res.v[1][0]; g[fa[x]][0] += max(f[x][0], f[x][1]), g[fa[x]][1] += f[x][0]; x = fa[x]; &#125; printf("%d\n", max(f[1][0], f[1][1])); &#125; return 0;&#125; § 3 例题二=&gt; luogu 4751 动态dp【加强版】§ 3.1 题意同例题一。强制在线，每次操作给出 $x$，实际修改的点为 $x \oplus lastans$。 $n,m \leq 10^6$。 § 3.2 分析本题的数据范围要求了更优秀的复杂度。 考虑 LCT，复杂度 $O((n\log n+q\log n)$ 符合题目要求，但因常数过大而表现不理想。 由于本题不需要动态的 link，cut 以及换根操作，我们可以构造一种类似 LCT 的静态数据结构。 § 3.2.1 全局平衡二叉树类似 LCT，我们将树的每条重链用一棵辅助二叉树维护，辅助树之间用虚边连接。 每个节点维护所在重链的辅助树的子树矩阵积。 事实上前面的线段树也是一种类似的结构，但每棵都保证了局部的绝对平衡，导致单次复杂度为 $O(\log^2n)$。 所以我们需要找到一种合适的构造方法，做到所有辅助树全体的总深度平衡。 辅助树的构造方法： 定义点 $u$ 的权重 $w_u=size_u-size_{hson_u}$，即所有轻儿子的 $size$ 和 $+1$。 对于每条重链，以带权重心为辅助树根，左右递归构造即可。 容易证明，这样构造出的全局平衡二叉树的深度为 $O(\log n)$。 这样修改时只需在辅助树上单步向上跳并更新答案，跳虚边时更新父亲的 $g$ 值即可。 总时间复杂度为 $O(n\log n+q\log n)$。 § 3.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;namespace fastio&#123; const int BUFSIZE = (1 &lt;&lt; 22) + 1; char ibuf[BUFSIZE], *iS, *iT, obuf[BUFSIZE], *oS = obuf, *oT = obuf + BUFSIZE, ch; int stk[20], tops = 0, neg; inline char getch()&#123; if(iS != iT) return *iS++; iT = (iS = ibuf) + fread(ibuf, 1, BUFSIZE, stdin); return iS == iT ? EOF : *iS++; &#125; inline void flush() &#123;fwrite(obuf, 1, oS - obuf, stdout), oS = obuf;&#125; inline void putch(const char &amp;ch) &#123;*oS++ = ch; if(oS == oT) flush();&#125; #define isdgt(ch) ((ch) &gt;= '0' &amp;&amp; (ch) &lt;= '9') inline void getint(int &amp;num)&#123; neg = 0; while(!isdigit(ch = getch())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getch())) num = num * 10 + (ch &amp; 15); if(neg) num = -num; &#125; inline void putint(int num)&#123; if(!num) return putch('0'); if(num &lt; 0) putch('-'), num = -num; while(num) stk[++tops] = num % 10 | 48, num /= 10; while(tops) putch(stk[tops--]); &#125;&#125;using fastio::getint;using fastio::putint;using fastio::putch;int n, m, a[1000005], f[1000005][2], g[1000005][2], ch[1000005][2], root;int fa[1000005], siz[1000005], hson[1000005], top[1000005];int w[1000005], s[1000005], p[1000005];struct Edge &#123;int np; Edge *nxt;&#125; E[2000005], *V[1000005];inline void addedge(const int &amp;u, const int &amp;v)&#123; static int tope = 0; E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;&#125;struct Matrix&#123; int v[2][2]; inline Matrix() &#123;v[0][0] = v[1][1] = 0, v[0][1] = v[1][0] = -inf;&#125; inline Matrix(int g0, int g1) &#123;v[0][0] = v[0][1] = g0, v[1][0] = g1, v[1][1] = -inf;&#125; inline Matrix operator * (const Matrix &amp;mat) const &#123; static Matrix res; res.v[0][0] = max(v[0][0] + mat.v[0][0], v[0][1] + mat.v[1][0]); res.v[0][1] = max(v[0][0] + mat.v[0][1], v[0][1] + mat.v[1][1]); res.v[1][0] = max(v[1][0] + mat.v[0][0], v[1][1] + mat.v[1][0]); res.v[1][1] = max(v[1][0] + mat.v[0][1], v[1][1] + mat.v[1][1]); return res; &#125;&#125; F[1000005], G[1000005];inline void update(int u) &#123;F[u] = F[ch[u][0]] * G[u] * F[ch[u][1]];&#125;int build(int l, int r)&#123; if(l &gt; r) return 0; int smid = (s[l - 1] + s[r] + 1) &gt;&gt; 1, L = l, R = r; while(L &lt; R)&#123; const int mid = L + R &gt;&gt; 1; if(s[mid] &gt;= smid) R = mid; else L = mid + 1; &#125; const int u = p[L]; fa[ch[u][0] = build(l, L - 1)] = u, fa[ch[u][1] = build(L + 1, r)] = u; return update(u), u;&#125;void dfs1(int u)&#123; siz[u] = 1, hson[u] = 0, f[u][1] = a[u]; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u])&#123; fa[ne-&gt;np] = u, dfs1(ne-&gt;np), siz[u] += siz[ne-&gt;np]; if(siz[ne-&gt;np] &gt; siz[hson[u]]) hson[u] = ne-&gt;np; f[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), f[u][1] += f[ne-&gt;np][0]; &#125; w[u] = siz[u] - siz[hson[u]];&#125;void dfs2(int u)&#123; g[u][1] = a[u]; if(hson[u]) top[hson[u]] = top[u], dfs2(hson[u]); for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u] &amp;&amp; ne-&gt;np != hson[u])&#123; top[ne-&gt;np] = ne-&gt;np, dfs2(ne-&gt;np); g[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), g[u][1] += f[ne-&gt;np][0]; &#125; G[u] = Matrix(g[u][0], g[u][1]); if(top[u] == u)&#123; int cnt = 0, fu = fa[u]; for(register int v = u; v; v = hson[v]) p[++cnt] = v, s[cnt] = s[cnt - 1] + w[v]; fa[root = build(1, cnt)] = fu; &#125;&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(a[i]); for(register int i = 1; i &lt; n; i++)&#123; int u, v; getint(u), getint(v); addedge(u, v), addedge(v, u); &#125; dfs1(1), top[1] = 1, dfs2(1); int lastans = 0; while(m--)&#123; int x, y; getint(x), getint(y), x ^= lastans; g[x][1] += y - a[x], a[x] = y, G[x] = Matrix(g[x][0], g[x][1]); while(x)&#123; int z = fa[x]; if(ch[z][0] != x &amp;&amp; ch[z][1] != x) g[z][0] -= max(F[x].v[0][0], F[x].v[1][0]), g[z][1] -= F[x].v[0][0]; update(x); if(ch[z][0] != x &amp;&amp; ch[z][1] != x)&#123; g[z][0] += max(F[x].v[0][0], F[x].v[1][0]), g[z][1] += F[x].v[0][0]; G[z] = Matrix(g[z][0], g[z][1]); &#125; x = z; &#125; putint(lastans = max(F[root].v[0][0], F[root].v[1][0])), putch('\n'); &#125; return fastio::flush(), 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>动态DP</tag>
        <tag>树链剖分</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语假名随机测试器]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%97%A5%E8%AF%AD%E5%81%87%E5%90%8D%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[日语假名随机测试器，灵感来自机房巨魔 High_Cold 以及 Vishford。不定期更新。 Version 0.0.1: kana_v0.0.1.exe。 Version 0.1.0: kana_v0.1.0.exe，查看 README。 Version 0.2.0: kana_v0.2.0.exe，查看 README。]]></content>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烫烫烫烫烫烫烫]]></title>
    <url>%2F2018%2F10%2F25%2F%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%2F</url>
    <content type="text"><![CDATA[手持两把锟斤拷，口中疾呼烫烫烫。脚踏千朵屯屯屯，笑看万物锘锘锘。]]></content>
      <tags>
        <tag>OI-story</tag>
      </tags>
  </entry>
</search>
