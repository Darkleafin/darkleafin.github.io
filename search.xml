<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[EZOI][1211NOI模拟赛]LCM]]></title>
    <url>%2F2018%2F12%2F12%2FEZOI-1211NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-LCM%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定一个大小为 $n$ 的数集 $S$，求 $\sum\limits_{S’ \subseteq S,S’ \neq \emptyset} {\rm LCM}(S’)$，即 $S$ 所有非空子集的 ${\rm LCM}$ 和。 $n \leq 2000,a_i \leq 200$。 § 2 分析首先发现 $a_i \leq 200$ 很小，考虑是否可以分解质因数统计。但 $200$ 以内的质数有 $46$ 个，组成的 ${\rm LCM}$ 值域过大。 考虑根号分治，观察发现 $\gt \sqrt{a_i} \approx 14$ 的质数的幂次最高为 $1$，而 $\leq 14$ 的质数只有 $6$ 个，分别为 $2,3,5,7,11,13$，其最高幂次分别为 $7,4,3,2,2,2$。 所以若只考虑 $2,3,5,7,11,13$，则 ${\rm LCM}$ 的不同值至多只有 $8\times5\times4\times3\times3\times3=4320$ 种。 我们将 $a_i$ 按除完 $2,3,5,7,11,13$ 后剩下的值 $c_i$ 分类，可以证明 $c_i=1 $ 或 $\gt 13$ 的质数。 令 $f_{c,p_1,p_2,p_3,p_4,p_5,p_6}$ 表示除完后剩下的值为 $c$ 时，是 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 因数的数的个数： 12345678for(register int i = 1; i &lt;= n; i++) for(register int p1 = a[i][1]; p1 &lt;= mx[1]; p1++) for(register int p2 = a[i][2]; p2 &lt;= mx[2]; p2++) for(register int p3 = a[i][3]; p3 &lt;= mx[3]; p3++) for(register int p4 = a[i][4]; p4 &lt;= mx[4]; p4++) for(register int p5 = a[i][5]; p5 &lt;= mx[5]; p5++) for(register int p6 = a[i][6]; p6 &lt;= mx[6]; p6++) f[c[i]][p1][p2][p3][p4][p5][p6]++; 令 $g_{p1,p2,p3,p4,p5,p6}$ 表示不考虑 $\gt 13$ 的因子时 ${\rm LCM}$ 为 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 的因数的子集数。 首先考虑除完后剩下的值 $c=1$ 时，$F=f_{1,p_1,p_2,p_3,p_4,p_5,p_6}$ 个数中的每个要么选要么不选，共有 $2^F$ 种可能： 1234567for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) g[p1][p2][p3][p4][p5][p6] = bin[f[1][p1][p2][p3][p4][p5][p6]]; 然后考虑除完后剩下的值 $c\gt 13$ 时，$F=f_{c,p_1,p_2,p_3,p_4,p_5,p_6}$ 个数中，都不选有 $1$ 种可能，选至少一个都会导致 ${\rm LCM}$ 扩大 $c$ 倍，由于只需统计 ${\rm LCM}$ 的和，可将一种算作 $c$ 种，等价于共有 $1+c\times(2^F-1)$ 种可能： 12345678910for(register int i = 1; i &lt;= 40; i++)&#123; const int &amp;r = rem[i]; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) (g[p1][p2][p3][p4][p5][p6] *= (r * (bin[f[r][p1][p2][p3][p4][p5][p6]] - 1LL + MOD) + 1LL) % MOD) %= MOD;&#125; 接下来通过容斥原理即可将 $g_{p1,p2,p3,p4,p5,p6}$ 转化为不考虑 $\gt 13$ 的因子时 ${\rm LCM}$ 严格等于 $2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}$ 的子集数，注意容斥要从大到小进行： 12345678910111213141516for(register int p1 = mx[1]; ~p1; p1--) for(register int p2 = mx[2]; ~p2; p2--) for(register int p3 = mx[3]; ~p3; p3--) for(register int p4 = mx[4]; ~p4; p4--) for(register int p5 = mx[5]; ~p5; p5--) for(register int p6 = mx[6]; ~p6; p6--) for(register int d1 = 0; d1 &lt;= 1 &amp;&amp; d1 &lt;= p1; d1++) for(register int d2 = 0; d2 &lt;= 1 &amp;&amp; d2 &lt;= p2; d2++) for(register int d3 = 0; d3 &lt;= 1 &amp;&amp; d3 &lt;= p3; d3++) for(register int d4 = 0; d4 &lt;= 1 &amp;&amp; d4 &lt;= p4; d4++) for(register int d5 = 0; d5 &lt;= 1 &amp;&amp; d5 &lt;= p5; d5++) for(register int d6 = 0; d6 &lt;= 1 &amp;&amp; d6 &lt;= p6; d6++) if(d1 | d2 | d3 | d4 | d5 | d6)&#123; if(d1 ^ d2 ^ d3 ^ d4 ^ d5 ^ d6) (g[p1][p2][p3][p4][p5][p6] += MOD - g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; else (g[p1][p2][p3][p4][p5][p6] += g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; &#125; 最后答案即为 $\sum\limits_{p1,p2,p3,p4,p5,p6}2^{p_1}\times3^{p_2}\times5^{p_3}\times7^{p_4}\times11^{p_5}\times13^{p_6}\times g_{p1,p2,p3,p4,p5,p6}$ 减去 $1$，即除去空集。 总时间复杂度为 $O(8\times5\times4\times3\times3\times3\times(n+40+2^6))​$。 § 3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MOD 1000000007using namespace std;typedef long long ll;const int prm[7] = &#123;1, 2, 3, 5, 7, 11, 13&#125;;const int rem[41] = &#123;1, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199&#125;;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, mx[7], a[2005][7], c[2005], v[8][5][4][3][3][3], f[205][8][5][4][3][3][3], bin[2005], ans;ll g[8][5][4][3][3][3];int main()&#123; getint(n), bin[0] = 1; for(register int i = 1; i &lt;= n; i++) bin[i] = (bin[i - 1] &lt;&lt; 1) % MOD; for(register int i = 1; i &lt;= n; i++)&#123; int v; getint(v); for(register int j = 1; j &lt;= 6; j++) while(v % prm[j] == 0)&#123; if(++a[i][j] &gt; mx[j]) mx[j] = a[i][j]; v /= prm[j]; &#125; c[i] = v; &#125; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++)&#123; if(p1) v[p1][p2][p3][p4][p5][p6] = v[p1 - 1][p2][p3][p4][p5][p6] * 2 % MOD; else if(p2) v[p1][p2][p3][p4][p5][p6] = v[p1][p2 - 1][p3][p4][p5][p6] * 3 % MOD; else if(p3) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3 - 1][p4][p5][p6] * 5 % MOD; else if(p4) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4 - 1][p5][p6] * 7 % MOD; else if(p5) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4][p5 - 1][p6] * 11 % MOD; else if(p6) v[p1][p2][p3][p4][p5][p6] = v[p1][p2][p3][p4][p5][p6 - 1] * 13 % MOD; else v[p1][p2][p3][p4][p5][p6] = 1; &#125; // 预处理 2^p1 * 3^p2 * 5^p3 * 7^p4 * 11^p5 * 13^p6 的值 for(register int i = 1; i &lt;= n; i++) for(register int p1 = a[i][1]; p1 &lt;= mx[1]; p1++) for(register int p2 = a[i][2]; p2 &lt;= mx[2]; p2++) for(register int p3 = a[i][3]; p3 &lt;= mx[3]; p3++) for(register int p4 = a[i][4]; p4 &lt;= mx[4]; p4++) for(register int p5 = a[i][5]; p5 &lt;= mx[5]; p5++) for(register int p6 = a[i][6]; p6 &lt;= mx[6]; p6++) f[c[i]][p1][p2][p3][p4][p5][p6]++; // 按 c[i] 分组统计可能对 LCM = 2^p1 * 3^p2 * 5^p3 * 7^p4 * 11^p5 * 13^p6 有贡献的数的个数 for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) g[p1][p2][p3][p4][p5][p6] = bin[f[1][p1][p2][p3][p4][p5][p6]]; // c[i] = 1 的对答案贡献倍数为 2^f for(register int i = 1; i &lt;= 40; i++)&#123; const int &amp;r = rem[i]; for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) (g[p1][p2][p3][p4][p5][p6] *= (r * (bin[f[r][p1][p2][p3][p4][p5][p6]] - 1LL + MOD) + 1LL) % MOD) %= MOD; &#125; // c[i] &gt; 13 的对答案贡献倍数为 1 + (c[i] * 2^f - 1) for(register int p1 = mx[1]; ~p1; p1--) for(register int p2 = mx[2]; ~p2; p2--) for(register int p3 = mx[3]; ~p3; p3--) for(register int p4 = mx[4]; ~p4; p4--) for(register int p5 = mx[5]; ~p5; p5--) for(register int p6 = mx[6]; ~p6; p6--) for(register int d1 = 0; d1 &lt;= 1 &amp;&amp; d1 &lt;= p1; d1++) for(register int d2 = 0; d2 &lt;= 1 &amp;&amp; d2 &lt;= p2; d2++) for(register int d3 = 0; d3 &lt;= 1 &amp;&amp; d3 &lt;= p3; d3++) for(register int d4 = 0; d4 &lt;= 1 &amp;&amp; d4 &lt;= p4; d4++) for(register int d5 = 0; d5 &lt;= 1 &amp;&amp; d5 &lt;= p5; d5++) for(register int d6 = 0; d6 &lt;= 1 &amp;&amp; d6 &lt;= p6; d6++) if(d1 | d2 | d3 | d4 | d5 | d6)&#123; if(d1 ^ d2 ^ d3 ^ d4 ^ d5 ^ d6) (g[p1][p2][p3][p4][p5][p6] += MOD - g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; else (g[p1][p2][p3][p4][p5][p6] += g[p1 - d1][p2 - d2][p3 - d3][p4 - d4][p5 - d5][p6 - d6]) %= MOD; &#125; // 通过容斥将"小于等于"转化为严格等于 for(register int p1 = 0; p1 &lt;= mx[1]; p1++) for(register int p2 = 0; p2 &lt;= mx[2]; p2++) for(register int p3 = 0; p3 &lt;= mx[3]; p3++) for(register int p4 = 0; p4 &lt;= mx[4]; p4++) for(register int p5 = 0; p5 &lt;= mx[5]; p5++) for(register int p6 = 0; p6 &lt;= mx[6]; p6++) ans = (ans + g[p1][p2][p3][p4][p5][p6] * v[p1][p2][p3][p4][p5][p6]) % MOD; printf("%d\n", (ans + MOD - 1) % MOD); return 0;&#125;]]></content>
      <tags>
        <tag>根号分治</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1211NOI模拟赛]Xor]]></title>
    <url>%2F2018%2F12%2F12%2FEZOI-1211NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-Xor%2F</url>
    <content type="text"><![CDATA[§ 1 题意给定简单无向连通带权图 $G=\lt V,E\gt$，其中对于 $u \in V$ 有点权 $W_u$，对于 $(i,j) \in E$ 有边权 $w_{i,j}$。 定义边集 $E$ 的权值为 $\bigoplus\limits_{(i,j) \in E} w_{i,j}$。 若一个割 $C$ 将图 $G$ 的点集 $V$ 分成 $S,T$ 两部分，其中 $S \cup T=V$，则简记为 $C=\lt S,T\gt$。 定义一个割 $C$ 是合法的，当且仅当对于 $\forall S’ \subseteq S,S’ \neq \emptyset$，割边集 $C’=\lt S’,T’\gt(T’=V-S’)$ 的权值均非 $0$。 求合法割集中 $\sum\limits_{u \in S}W_u-\sum\limits_{u \in T}W_u$ 的最大值。 $n \leq 10^5,m \leq 2*10^5,W_u \leq 10^{12},w_{i,j} \lt 2^{63}$。 § 2 分析边 $(i,j)$ 在割集 $C=\lt S,T\gt$ 中，当且仅当它的一个端点在 $S$ 中，另一个在 $T$ 中。此时割集权值要异或 $w_{i,j}$。 如果边 $(i,j)$ 的两个端点均在 $S$ 中，可以视作割集权值异或两次 $w_{i,j}$，等价于没有贡献。 记点 $u$ 所有出边的边权异或和 $f_u=\bigoplus\limits_{(u,i) \in E} w_{u,i}$，则割 $C=\lt S,T\gt$ 的权值为 $\bigoplus\limits_{u \in S}f_u$。 由于合法割集需要满足不存在 $S’ \subseteq S,S’ \neq \emptyset$ 使得割 $C’=\lt S’,V-S’\gt$ 权值为 $0$，所以 $S$ 中的点的 $f_u$ 要线性无关，使用线性基按 $W_u$ 从大到小贪心即可。 总时间复杂度为 $O(n\log w)$。 § 3 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;template &lt;typename T&gt; inline void getint(T &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, m; ll bas[63], tot = 0, ans = 0;struct Node &#123;ll w, f;&#125; p[100005];inline bool operator &lt; (const Node &amp;p1, const Node &amp;p2) &#123;return p1.w &gt; p2.w;&#125;inline int ins(ll val)&#123; for(register int i = 62; ~i; i--) if(val &amp; (1LL &lt;&lt; i)) if(bas[i]) val ^= bas[i]; else return bas[i] = val, 1; return 0;&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(p[i].w), tot += p[i].w; for(register int i = 1; i &lt;= m; i++)&#123; int u, v; ll w; getint(u), getint(v), getint(w); p[u].f ^= w, p[v].f ^= w; &#125; sort(p + 1, p + n + 1); for(register int i = 1; i &lt;= n; i++) if(ins(p[i].f)) ans += p[i].w; printf("%lld\n", ans * 2 - tot); return 0;&#125;]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[EZOI][1208NOI模拟赛]Forest]]></title>
    <url>%2F2018%2F12%2F10%2FEZOI-1208NOI%E6%A8%A1%E6%8B%9F%E8%B5%9B-Forest%2F</url>
    <content type="text"><![CDATA[§ 1 题意有一个点数为 $n$ 的有向图，每个点出度均为 $1$。 给出每个点的后继 $A_i$ 和点权 $B_i$，保证 $A_i \neq i$ 且 $A_{A_i} \neq i$。 记点 $i$ 的总度数为 $D_i$，并定义 $E_i = \lfloor \frac{B_i}{D_i} \rfloor$，稠密度 $C_i=B_i-D_i*E_i+\sum_{j=1}^{D_i}E_{P_j}$。 请实现一个稠密度分析仪，支持以下三种操作： $1$ $i$ $j$ ：把 $i$ 点的后继改为 $j$，即令 $A_i=j$，保证 $j \neq i$ 且 $A_j \neq i$。 $2​$ $i​$ ：询问 $i​$ 点的稠密度 $C_i​$。 $3$ ：询问所有节点中，$C_i$ 的最小值和最大值。 $3 \leq n \leq 10^5$，$1 \leq q \leq 10^5$，$1 \leq B_i \leq 10^{12}$，$1 \leq A_i \leq n$。 题目来源：Codeforces 643D - Bearish Fanpages。 § 2 分析首先化简得 $C_i=B_i \% D_i+\sum_{j=1}^{D_i}E_{P_j}$。 考虑操作 $1$，将点 $i$ 的后继从 $A_i$ 改为 $j$，若 $A_i==j$ 则跳过，否则考虑改动所造成的影响： $A_i$ 的度数减少 $1$，即 $D_{A_i}$ 减去 $1$，导致 $E_{A_i} = \lfloor \frac{B_{A_i}}{D_{A_i}} \rfloor$ 改变。 $j$ 的度数增加 $1$，即 $D_j$ 加上 $1$，导致 $E_j = \lfloor \frac{B_j}{D_j} \rfloor$ 改变。 连边情况改变，即最后令 $A_i=j​$。 当某个 $E_i$ 改变时，$C_{i}$、$C_{A_i}$ 以及 $i$ 所有前驱 $j$ 的 $C_j$ 都要改变。 § 2.1 弱化版若没有 $3$ 操作，则我们考虑维护 $C’_i=C_i-E_{A_i}$，即不计后继贡献时的答案。 执行 $1$ $i$ $j$ 操作时，由于不计后继贡献， $C’_i$ 不会改变，重算 $E_{A_i}$ 和 $E_j$，更新 $C’_{A_i}$、$C’_{A_{A_i}}$、$C’_j$ 和 $C’_{A_j}$。 执行 $2$ $i$ 操作时，直接输出 $C’_i+E_{A_i}$ 即可。 总体可在 $O(n)$ 时间内解决。 § 2.2 维护极值考虑 $3$ 操作，我们可以对每个节点 $i$ 用 multiset 维护其前驱 $C’_i$ 的极值，然后取每个 multiset 中的极值再放入 multiset 中维护，即可在 $O(n\log n)$ 时间内解决本题。 注意每次更新 $C’_i$ 时，先在维护总体极值的 multiset 中删除，然后在父节点的 multiset 中删除，修改 $C’_i$ 后再在父节点的 multiset 中插入，最后在总体极值的 multiset 中插入即可。 § 3 代码注：C[i] 表示本文中的 $C’_i$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;typedef long long ll;template &lt;typename T&gt; inline void getint(T &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, q, A[100005], D[100005];ll B[100005], E[100005], C[100005];multiset&lt;ll&gt; s[100005], maxs, mins;inline void ins(const int &amp;u)&#123; if(s[u].empty()) return; maxs.insert(*s[u].rbegin() + E[u]); mins.insert(*s[u].begin() + E[u]);&#125;inline void del(const int &amp;u)&#123; if(s[u].empty()) return; maxs.erase(maxs.find(*s[u].rbegin() + E[u])); mins.erase(mins.find(*s[u].begin() + E[u]));&#125;int main()&#123; getint(n), getint(q); for(register int i = 1; i &lt;= n; i++) getint(B[i]), D[i] = 2; for(register int i = 1; i &lt;= n; i++) getint(A[i]), D[A[i]]++; for(register int i = 1; i &lt;= n; i++) E[i] = B[i] / D[i], C[i] = B[i] % D[i] + E[i]; for(register int i = 1; i &lt;= n; i++) C[A[i]] += E[i]; for(register int i = 1; i &lt;= n; i++) s[A[i]].insert(C[i]); for(register int i = 1; i &lt;= n; i++) ins(i); while(q--)&#123; int opt, u, v; getint(opt); if(opt == 1)&#123; getint(u), getint(v); if(A[u] == v) continue; int p = A[u], q = A[p], r = A[q]; del(p), s[p].erase(s[p].find(C[u])); del(q), s[q].erase(s[q].find(C[p])); del(r), s[r].erase(s[r].find(C[q])); C[p] -= B[p] % D[p] + E[u] + E[p], C[q] -= E[p]; E[p] = B[p] / --D[p]; C[p] += B[p] % D[p] + E[p], C[q] += E[p]; ins(p); s[q].insert(C[p]), ins(q); s[r].insert(C[q]), ins(r); p = A[u] = v, q = A[p], r = A[q]; del(p); del(q), s[q].erase(s[q].find(C[p])); del(r), s[r].erase(s[r].find(C[q])); C[p] -= B[p] % D[p] + E[p], C[q] -= E[p]; E[p] = B[p] / ++D[p]; C[p] += B[p] % D[p] + E[u] + E[p], C[q] += E[p]; s[p].insert(C[u]), ins(p); s[q].insert(C[p]), ins(q); s[r].insert(C[q]), ins(r); &#125; else if(opt == 2) getint(u), printf("%lld\n", C[u] + E[A[u]]); else if(opt == 3) printf("%lld %lld\n", *mins.begin(), *maxs.rbegin()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈动态DP]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%B5%85%E8%B0%88%E5%8A%A8%E6%80%81DP%2F</url>
    <content type="text"><![CDATA[§ 1 前言本文大量参考 txc 巨爷的《基于变换合并的树上动态DP的链分治算法和全局平衡二叉树学习笔记》一文。在某些问题中，我们需要实现对某种 DP 的权值修改，以及快速询问全局或子结构的 DP 值。 如果我们能找到一种满足结合律的运算来描述转移过程的话，就可以用数据结构维护合并，降低复杂度。 § 2 例题一=&gt; luogu 4719 【模板】动态dp§ 2.1 题意给定一棵有 $i$ 个点的树，第 $i$ 个点的点权为 $a_i$。 有 $m$ 次操作，每次操作给定 $x,y$，表示将点 $x$ 的权值修改为 $y$。 求每次操作后这棵树的最大权独立集的权值，其中独立集指任意两个顶点不相邻的点集。 $n,m \leq 10^5$。 § 2.2 分析本题的模型为树上带修最大权独立集，是动态 DP 的模板题。 § 2.2.1 弱化版首先考虑如果没有修改操作，我们可以直接进行 $\Theta(n)$ 的树形 DP。 令 $f_{u,0/1}$ 表示以 $u$ 为根的子树中，不选 / 选 $u$ 时的最大权独立集的权值，则有 \begin{align} f_{u,0}&=\sum_{u→v}max\{f_{v,0},f_{v,1}\} \\ f_{u,1}&=a_u+\sum_{u→v}f_{v,0}\end{align}§ 2.2.2 重写转移考虑树链剖分，求出 $u$ 的重儿子 $hson_u$。单独取出重儿子贡献的一项，则 DP 转化为 \begin{align} f_{u,0}&=max\{f_{hson_u,0},f_{hson_u,1}\}+\sum_{u→v,v\neq hson_u}max\{f_{v,0},f_{v,1}\} \\ f_{u,1}&=a_u+f_{hson_u,0}+\sum_{u→v,v\neq hson_u}f_{v,0}\end{align}记 \begin{align} g_{u,0}&=\sum_{u→v,v\neq hson_u}max\{f_{v,0},f_{v,1}\} \\ g_{u,1}&=a_u+\sum_{u→v,v\neq hson_u}f_{v,0}\end{align}则有 \begin{align} f_{u,0}&=max\{f_{hson_u,0},f_{hson_u,1}\}+g_{u,0} \\ f_{u,1}&=f_{hson_u,0}+g_{u,1}\end{align}§ 2.2.3 矩阵优化我们重新定义矩阵乘法 $C=A*B$ 来描述这个转移，令 $\begin{align} c_{i,j}=\max \limits_k(a_{i,k}+b_{k,j}) \end{align} $ 则转移可写为 \begin{equation} \left( \begin{array}{c} f_{u,0} \\ f_{u,1} \end{array} \right)= \left( \begin{array}{cc} g_{u,0} & g_{u,0} \\ g_{u,1} & -\infty \end{array} \right) \left( \begin{array}{c} f_{hson_u,0} \\ f_{hson_u,1} \end{array} \right) \end{equation}可以证明重定义的矩阵乘法是具有结合律的，且存在单位矩阵\begin{equation}\left( \begin{array}{cc} 0 & -\infty \\ -\infty & 0 \end{array} \right) \end{equation}。 求一个点的 DP 值时，只需将该点沿重链走到底的矩阵相乘即可。 由于重链在 dfs 序上连续，可以用线段树维护区间矩阵乘积。修改类似树链剖分，重复以下步骤： 更新当前点的矩阵； 跳到重链顶端，同时计算 DP 值，更新父节点的 $g$ 值，并跳到父节点。 这样单次修改复杂度为 $O(\log^2n)$，查询复杂度为 $O(\log n)$。 § 2.3 代码注：leafdfn[u] 表示点 $u​$ 所在重链底部节点的 dfs 序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;inline void getint(int &amp;num)&#123; register int ch, neg = 0; while(!isdigit(ch = getchar())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getchar())) num = num * 10 + (ch &amp; 15); if(neg) num = -num;&#125;int n, m, a[100005], f[100005][2], g[100005][2];int fa[100005], siz[100005], hson[100005];int dfn[100005], dfstime = 0, id[100005], top[100005], leafdfn[100005];struct Edge &#123;int np; Edge *nxt;&#125; E[200005], *V[100005];inline void addedge(const int &amp;u, const int &amp;v)&#123; static int tope = 0; E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;&#125;struct Matrix&#123; int v[2][2]; inline Matrix() &#123;v[0][0] = v[1][1] = 0, v[0][1] = v[1][0] = -inf;&#125; inline Matrix(int g0, int g1) &#123;v[0][0] = v[0][1] = g0, v[1][0] = g1, v[1][1] = -inf;&#125; inline Matrix operator * (const Matrix &amp;mat) const&#123; static Matrix res; res.v[0][0] = max(v[0][0] + mat.v[0][0], v[0][1] + mat.v[1][0]); res.v[0][1] = max(v[0][0] + mat.v[0][1], v[0][1] + mat.v[1][1]); res.v[1][0] = max(v[1][0] + mat.v[0][0], v[1][1] + mat.v[1][0]); res.v[1][1] = max(v[1][0] + mat.v[0][1], v[1][1] + mat.v[1][1]); return res; &#125;&#125; s[400005];void dfs1(int u)&#123; siz[u] = 1, hson[u] = 0, f[u][1] = a[u]; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u])&#123; fa[ne-&gt;np] = u, dfs1(ne-&gt;np), siz[u] += siz[ne-&gt;np]; if(siz[ne-&gt;np] &gt; siz[hson[u]]) hson[u] = ne-&gt;np; f[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), f[u][1] += f[ne-&gt;np][0]; &#125;&#125;void dfs2(int u)&#123; id[dfn[u] = ++dfstime] = u, g[u][1] = a[u]; if(hson[u]) top[hson[u]] = top[u], dfs2(hson[u]), leafdfn[u] = leafdfn[hson[u]]; else leafdfn[u] = dfstime; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u] &amp;&amp; ne-&gt;np != hson[u])&#123; top[ne-&gt;np] = ne-&gt;np, dfs2(ne-&gt;np); g[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), g[u][1] += f[ne-&gt;np][0]; &#125;&#125;#define lch (u &lt;&lt; 1)#define rch (u &lt;&lt; 1 | 1)void build(int u, int l, int r)&#123; if(l == r) &#123;s[u] = Matrix(g[id[l]][0], g[id[l]][1]); return;&#125; const int mid = l + r &gt;&gt; 1; build(lch, l, mid), build(rch, mid + 1, r); s[u] = s[lch] * s[rch];&#125;void modify(int u, int l, int r, int pos)&#123; if(l == r) &#123;s[u] = Matrix(g[id[l]][0], g[id[l]][1]); return;&#125; const int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) modify(lch, l, mid, pos); else modify(rch, mid + 1, r, pos); s[u] = s[lch] * s[rch];&#125;Matrix query(int u, int l, int r, int ql, int qr)&#123; if(l == ql &amp;&amp; r == qr) return s[u]; const int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(lch, l, mid, ql, qr); if(ql &gt; mid) return query(rch, mid + 1, r, ql, qr); return query(lch, l, mid, ql, mid) * query(rch, mid + 1, r, mid + 1, qr);&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(a[i]); for(register int i = 1; i &lt; n; i++)&#123; int u, v; getint(u), getint(v); addedge(u, v), addedge(v, u); &#125; dfs1(1), top[1] = 1, dfs2(1); build(1, 1, n); while(m--)&#123; int x, y; getint(x), getint(y); g[x][1] += y - a[x], a[x] = y; while(x)&#123; modify(1, 1, n, dfn[x]), x = top[x]; Matrix res = query(1, 1, n, dfn[x], leafdfn[x]); g[fa[x]][0] -= max(f[x][0], f[x][1]), g[fa[x]][1] -= f[x][0]; f[x][0] = res.v[0][0], f[x][1] = res.v[1][0]; g[fa[x]][0] += max(f[x][0], f[x][1]), g[fa[x]][1] += f[x][0]; x = fa[x]; &#125; printf("%d\n", max(f[1][0], f[1][1])); &#125; return 0;&#125; § 3 例题二=&gt; luogu 4751 动态dp【加强版】§ 3.1 题意同例题一。强制在线，每次操作给出 $x$，实际修改的点为 $x \oplus lastans$。 $n,m \leq 10^6$。 § 3.2 分析本题的数据范围要求了更优秀的复杂度。 考虑 LCT，复杂度 $O((n\log n+q\log n)$ 符合题目要求，但因常数过大而表现不理想。 由于本题不需要动态的 link，cut 以及换根操作，我们可以构造一种类似 LCT 的静态数据结构。 § 3.2.1 全局平衡二叉树类似 LCT，我们将树的每条重链用一棵辅助二叉树维护，辅助树之间用虚边连接。 每个节点维护所在重链的辅助树的子树矩阵积。 事实上前面的线段树也是一种类似的结构，但每棵都保证了局部的绝对平衡，导致单次复杂度为 $O(\log^2n)$。 所以我们需要找到一种合适的构造方法，做到所有辅助树全体的总深度平衡。 辅助树的构造方法： 定义点 $u$ 的权重 $w_u=size_u-size_{hson_u}$，即所有轻儿子的 $size$ 和 $+1$。 对于每条重链，以带权重心为辅助树根，左右递归构造即可。 容易证明，这样构造出的全局平衡二叉树的深度为 $O(\log n)$。 这样修改时只需在辅助树上单步向上跳并更新答案，跳虚边时更新父亲的 $g$ 值即可。 总时间复杂度为 $O(n\log n+q\log n)$。 § 3.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;namespace fastio&#123; const int BUFSIZE = (1 &lt;&lt; 22) + 1; char ibuf[BUFSIZE], *iS, *iT, obuf[BUFSIZE], *oS = obuf, *oT = obuf + BUFSIZE, ch; int stk[20], tops = 0, neg; inline char getch()&#123; if(iS != iT) return *iS++; iT = (iS = ibuf) + fread(ibuf, 1, BUFSIZE, stdin); return iS == iT ? EOF : *iS++; &#125; inline void flush() &#123;fwrite(obuf, 1, oS - obuf, stdout), oS = obuf;&#125; inline void putch(const char &amp;ch) &#123;*oS++ = ch; if(oS == oT) flush();&#125; #define isdgt(ch) ((ch) &gt;= '0' &amp;&amp; (ch) &lt;= '9') inline void getint(int &amp;num)&#123; neg = 0; while(!isdigit(ch = getch())) if(ch == '-') neg = 1; num = ch &amp; 15; while(isdigit(ch = getch())) num = num * 10 + (ch &amp; 15); if(neg) num = -num; &#125; inline void putint(int num)&#123; if(!num) return putch('0'); if(num &lt; 0) putch('-'), num = -num; while(num) stk[++tops] = num % 10 | 48, num /= 10; while(tops) putch(stk[tops--]); &#125;&#125;using fastio::getint;using fastio::putint;using fastio::putch;int n, m, a[1000005], f[1000005][2], g[1000005][2], ch[1000005][2], root;int fa[1000005], siz[1000005], hson[1000005], top[1000005];int w[1000005], s[1000005], p[1000005];struct Edge &#123;int np; Edge *nxt;&#125; E[2000005], *V[1000005];inline void addedge(const int &amp;u, const int &amp;v)&#123; static int tope = 0; E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;&#125;struct Matrix&#123; int v[2][2]; inline Matrix() &#123;v[0][0] = v[1][1] = 0, v[0][1] = v[1][0] = -inf;&#125; inline Matrix(int g0, int g1) &#123;v[0][0] = v[0][1] = g0, v[1][0] = g1, v[1][1] = -inf;&#125; inline Matrix operator * (const Matrix &amp;mat) const &#123; static Matrix res; res.v[0][0] = max(v[0][0] + mat.v[0][0], v[0][1] + mat.v[1][0]); res.v[0][1] = max(v[0][0] + mat.v[0][1], v[0][1] + mat.v[1][1]); res.v[1][0] = max(v[1][0] + mat.v[0][0], v[1][1] + mat.v[1][0]); res.v[1][1] = max(v[1][0] + mat.v[0][1], v[1][1] + mat.v[1][1]); return res; &#125;&#125; F[1000005], G[1000005];inline void update(int u) &#123;F[u] = F[ch[u][0]] * G[u] * F[ch[u][1]];&#125;int build(int l, int r)&#123; if(l &gt; r) return 0; int smid = (s[l - 1] + s[r] + 1) &gt;&gt; 1, L = l, R = r; while(L &lt; R)&#123; const int mid = L + R &gt;&gt; 1; if(s[mid] &gt;= smid) R = mid; else L = mid + 1; &#125; const int u = p[L]; fa[ch[u][0] = build(l, L - 1)] = u, fa[ch[u][1] = build(L + 1, r)] = u; return update(u), u;&#125;void dfs1(int u)&#123; siz[u] = 1, hson[u] = 0, f[u][1] = a[u]; for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u])&#123; fa[ne-&gt;np] = u, dfs1(ne-&gt;np), siz[u] += siz[ne-&gt;np]; if(siz[ne-&gt;np] &gt; siz[hson[u]]) hson[u] = ne-&gt;np; f[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), f[u][1] += f[ne-&gt;np][0]; &#125; w[u] = siz[u] - siz[hson[u]];&#125;void dfs2(int u)&#123; g[u][1] = a[u]; if(hson[u]) top[hson[u]] = top[u], dfs2(hson[u]); for(register Edge *ne = V[u]; ne; ne = ne-&gt;nxt) if(ne-&gt;np != fa[u] &amp;&amp; ne-&gt;np != hson[u])&#123; top[ne-&gt;np] = ne-&gt;np, dfs2(ne-&gt;np); g[u][0] += max(f[ne-&gt;np][0], f[ne-&gt;np][1]), g[u][1] += f[ne-&gt;np][0]; &#125; G[u] = Matrix(g[u][0], g[u][1]); if(top[u] == u)&#123; int cnt = 0, fu = fa[u]; for(register int v = u; v; v = hson[v]) p[++cnt] = v, s[cnt] = s[cnt - 1] + w[v]; fa[root = build(1, cnt)] = fu; &#125;&#125;int main()&#123; getint(n), getint(m); for(register int i = 1; i &lt;= n; i++) getint(a[i]); for(register int i = 1; i &lt; n; i++)&#123; int u, v; getint(u), getint(v); addedge(u, v), addedge(v, u); &#125; dfs1(1), top[1] = 1, dfs2(1); int lastans = 0; while(m--)&#123; int x, y; getint(x), getint(y), x ^= lastans; g[x][1] += y - a[x], a[x] = y, G[x] = Matrix(g[x][0], g[x][1]); while(x)&#123; int z = fa[x]; if(ch[z][0] != x &amp;&amp; ch[z][1] != x) g[z][0] -= max(F[x].v[0][0], F[x].v[1][0]), g[z][1] -= F[x].v[0][0]; update(x); if(ch[z][0] != x &amp;&amp; ch[z][1] != x)&#123; g[z][0] += max(F[x].v[0][0], F[x].v[1][0]), g[z][1] += F[x].v[0][0]; G[z] = Matrix(g[z][0], g[z][1]); &#125; x = z; &#125; putint(lastans = max(F[root].v[0][0], F[root].v[1][0])), putch('\n'); &#125; return fastio::flush(), 0;&#125;]]></content>
      <tags>
        <tag>动态DP</tag>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语假名随机测试器]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%97%A5%E8%AF%AD%E5%81%87%E5%90%8D%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[日语假名随机测试器，灵感来自机房巨魔 High_Cold 以及 Vishford。不定期更新。 Version 0.0.1: kana_v0.0.1.exe。 Version 0.1.0: kana_v0.1.0.exe，查看 README。 Version 0.2.0: kana_v0.2.0.exe，查看 README。]]></content>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烫烫烫烫烫烫烫]]></title>
    <url>%2F2018%2F10%2F25%2F%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%E7%83%AB%2F</url>
    <content type="text"><![CDATA[手持两把锟斤拷，口中疾呼烫烫烫。脚踏千朵屯屯屯，笑看万物锘锘锘。]]></content>
      <tags>
        <tag>OI-story</tag>
      </tags>
  </entry>
</search>
